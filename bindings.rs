/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _SCHED_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __time_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const SCHED_COBALT: u32 = 42;
pub const SCHED_WEAK: u32 = 43;
pub const SCHED_SPORADIC: u32 = 10;
pub const SCHED_TP: u32 = 11;
pub const SCHED_QUOTA: u32 = 12;
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_XENO_BUILD_ARGS: &'static [u8; 56usize] =
    b" '--with-core=cobalt' '--enable-smp' '--enable-pshared'\0";
pub const CONFIG_XENO_BUILD_STRING: &'static [u8; 20usize] = b"x86_64-pc-linux-gnu\0";
pub const CONFIG_XENO_COBALT: u32 = 1;
pub const CONFIG_XENO_COMPILER: &'static [u8; 25usize] = b"gcc version 8.1.0 (GCC) \0";
pub const CONFIG_XENO_DEFAULT_PERIOD: u32 = 100000;
pub const CONFIG_XENO_FORTIFY: u32 = 1;
pub const CONFIG_XENO_HEAPMEM: u32 = 1;
pub const CONFIG_XENO_HOST_STRING: &'static [u8; 20usize] = b"x86_64-pc-linux-gnu\0";
pub const CONFIG_XENO_LORES_CLOCK_DISABLED: u32 = 1;
pub const CONFIG_XENO_PREFIX: &'static [u8; 13usize] = b"/usr/xenomai\0";
pub const CONFIG_XENO_PSHARED: u32 = 1;
pub const CONFIG_XENO_RAW_CLOCK_ENABLED: u32 = 1;
pub const CONFIG_XENO_SANITY: u32 = 1;
pub const CONFIG_XENO_TLS_MODEL: &'static [u8; 13usize] = b"initial-exec\0";
pub const CONFIG_XENO_UAPI_LEVEL: u32 = 15;
pub const CONFIG_XENO_VALGRIND_API: u32 = 1;
pub const CONFIG_XENO_VERSION_MAJOR: u32 = 3;
pub const CONFIG_XENO_VERSION_MINOR: u32 = 1;
pub const CONFIG_XENO_VERSION_STRING: &'static [u8; 4usize] = b"3.1\0";
pub const CONFIG_XENO_X86_VSYSCALL: u32 = 1;
pub const __BITS_PER_LONG: u32 = 64;
pub const XNOBJECT_NAME_LEN: u32 = 32;
pub const COBALT_SEM_MAGIC: u32 = 2256930567;
pub const COBALT_NAMED_SEM_MAGIC: u32 = 2256932109;
pub const SEM_FIFO: u32 = 1;
pub const SEM_PULSE: u32 = 2;
pub const SEM_PSHARED: u32 = 4;
pub const SEM_REPORT: u32 = 8;
pub const SEM_WARNDEL: u32 = 16;
pub const SEM_RAWCLOCK: u32 = 32;
pub const SEM_NOBUSYDEL: u32 = 64;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _ASSERT_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const sem_scope_attribute: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const COBALT_MAX_EXTCLOCKS: u32 = 64;
pub const TFD_WAKEUP: u32 = 4;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const XNSUSP: u32 = 1;
pub const XNPEND: u32 = 2;
pub const XNDELAY: u32 = 4;
pub const XNREADY: u32 = 8;
pub const XNDORMANT: u32 = 16;
pub const XNZOMBIE: u32 = 32;
pub const XNMAPPED: u32 = 64;
pub const XNRELAX: u32 = 128;
pub const XNMIGRATE: u32 = 256;
pub const XNHELD: u32 = 512;
pub const XNBOOST: u32 = 1024;
pub const XNSSTEP: u32 = 2048;
pub const XNLOCK: u32 = 4096;
pub const XNRRB: u32 = 8192;
pub const XNWARN: u32 = 16384;
pub const XNFPU: u32 = 32768;
pub const XNROOT: u32 = 65536;
pub const XNWEAK: u32 = 131072;
pub const XNUSER: u32 = 262144;
pub const XNJOINED: u32 = 524288;
pub const XNTRAPLB: u32 = 1048576;
pub const XNDEBUG: u32 = 2097152;
pub const XNDBGSTOP: u32 = 4194304;
pub const XNTIMEO: u32 = 1;
pub const XNRMID: u32 = 2;
pub const XNBREAK: u32 = 4;
pub const XNKICKED: u32 = 8;
pub const XNWAKEN: u32 = 16;
pub const XNROBBED: u32 = 32;
pub const XNCANCELD: u32 = 64;
pub const XNPIALERT: u32 = 128;
pub const XNSCHEDP: u32 = 256;
pub const XNCONTHI: u32 = 512;
pub const XNMOVED: u32 = 1;
pub const XNLBALERT: u32 = 2;
pub const XNDESCENT: u32 = 4;
pub const XNSYSRST: u32 = 8;
pub const XNHICCUP: u32 = 16;
pub const XNTHREAD_STATE_LABELS: &'static [u8; 24usize] = b"SWDRU..X.HbTlrt.....L.s\0";
pub const PTHREAD_WARNSW: u32 = 16384;
pub const PTHREAD_LOCK_SCHED: u32 = 4096;
pub const PTHREAD_DISABLE_LOCKBREAK: u32 = 1048576;
pub const PTHREAD_CONFORMING: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const libcopperplate_tag: u32 = 0;
pub const libcopperplate_cbi: u32 = 1;
pub const fnref_null: i32 = -1;
pub const MAX_FNLIBS: u32 = 16;
pub const MAX_FNREFS: u32 = 16;
pub const SYNCOBJ_FIFO: u32 = 0;
pub const SYNCOBJ_PRIO: u32 = 1;
pub const SYNCOBJ_LOCKED: u32 = 2;
pub const SYNCOBJ_FLUSHED: u32 = 1;
pub const SYNCOBJ_SIGNALED: u32 = 2;
pub const SYNCOBJ_DRAINWAIT: u32 = 4;
pub const SYNCOBJ_MAGIC: u32 = 4193886111;
pub const COBALT_MONITOR_GRANTED: u32 = 1;
pub const COBALT_MONITOR_DRAINED: u32 = 2;
pub const COBALT_MONITOR_SIGNALED: u32 = 3;
pub const COBALT_MONITOR_BROADCAST: u32 = 4;
pub const COBALT_MONITOR_PENDED: u32 = 8;
pub const COBALT_MONITOR_SHARED: u32 = 1;
pub const COBALT_MONITOR_WAITGRANT: u32 = 0;
pub const COBALT_MONITOR_WAITDRAIN: u32 = 1;
pub const _BITS_SIGNUM_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 23;
pub const SIGIOT: u32 = 6;
pub const SIGCLD: u32 = 20;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 32;
pub const _NSIG: u32 = 33;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 33;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const SIGSHADOW: u32 = 28;
pub const SIGSHADOW_ACTION_HARDEN: u32 = 1;
pub const SIGSHADOW_ACTION_BACKTRACE: u32 = 2;
pub const SIGSHADOW_ACTION_HOME: u32 = 3;
pub const SIGSHADOW_BACKTRACE_DEPTH: u32 = 16;
pub const SIGDEBUG: u32 = 24;
pub const sigdebug_marker: u32 = 4241424384;
pub const SIGDEBUG_UNDEFINED: u32 = 0;
pub const SIGDEBUG_MIGRATE_SIGNAL: u32 = 1;
pub const SIGDEBUG_MIGRATE_SYSCALL: u32 = 2;
pub const SIGDEBUG_MIGRATE_FAULT: u32 = 3;
pub const SIGDEBUG_MIGRATE_PRIOINV: u32 = 4;
pub const SIGDEBUG_NOMLOCK: u32 = 5;
pub const SIGDEBUG_WATCHDOG: u32 = 6;
pub const SIGDEBUG_RESCNT_IMBALANCE: u32 = 7;
pub const SIGDEBUG_LOCK_BREAK: u32 = 8;
pub const SIGDEBUG_MUTEX_SLEEP: u32 = 9;
pub const COBALT_DELAYMAX: u32 = 2147483647;
pub const CLOCK_COPPERPLATE: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const AVLH_APP_BITS: u32 = 28;
pub const AVL_LEFT: i32 = -1;
pub const AVL_UP: u32 = 0;
pub const AVL_RIGHT: u32 = 1;
pub const HEAPMEM_PAGE_SHIFT: u32 = 9;
pub const HEAPMEM_PAGE_SIZE: u32 = 512;
pub const HEAPMEM_PAGE_MASK: i32 = -512;
pub const HEAPMEM_MIN_LOG2: u32 = 4;
pub const HEAPMEM_MAX: u32 = 5;
pub const HEAPMEM_MIN_ALIGN: u32 = 16;
pub const HEAPMEM_MAX_EXTSZ: u32 = 4294966784;
pub const HEAPMEM_PGENT_BITS: u32 = 23;
pub const SCHED_CORE: u32 = 42;
pub const __THREAD_S_STARTED: u32 = 1;
pub const __THREAD_S_WARMUP: u32 = 2;
pub const __THREAD_S_ABORTED: u32 = 4;
pub const __THREAD_S_LOCKED: u32 = 8;
pub const __THREAD_S_ACTIVE: u32 = 16;
pub const __THREAD_S_SUSPENDED: u32 = 32;
pub const __THREAD_S_SAFE: u32 = 64;
pub const __THREAD_S_PERIODIC: u32 = 128;
pub const __THREAD_S_DEBUG: u32 = 2147483648;
pub const __THREAD_S_RUNNING: u32 = 0;
pub const __THREAD_S_DORMANT: u32 = 65536;
pub const __THREAD_S_WAIT: u32 = 131072;
pub const __THREAD_S_TIMEDWAIT: u32 = 262144;
pub const __THREAD_S_DELAYED: u32 = 524288;
pub const __THREAD_S_BREAK: u32 = 1572864;
pub const __THREAD_M_LOCK: u32 = 1;
pub const __THREAD_M_WARNSW: u32 = 2;
pub const __THREAD_M_CONFORMING: u32 = 4;
pub const __THREAD_M_SPARE0: u32 = 65536;
pub const __THREAD_M_SPARE1: u32 = 131072;
pub const __THREAD_M_SPARE2: u32 = 262144;
pub const __THREAD_M_SPARE3: u32 = 524288;
pub const __THREAD_M_SPARE4: u32 = 1048576;
pub const __THREAD_M_SPARE5: u32 = 2097152;
pub const __THREAD_M_SPARE6: u32 = 4194304;
pub const __THREAD_M_SPARE7: u32 = 8388608;
pub const _FCNTL_H: u32 = 1;
pub const __O_LARGEFILE: u32 = 0;
pub const F_GETLK64: u32 = 5;
pub const F_SETLK64: u32 = 6;
pub const F_SETLKW64: u32 = 7;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_EACCESS: u32 = 512;
pub const _BITS_STAT_H: u32 = 1;
pub const _STAT_VER_KERNEL: u32 = 0;
pub const _STAT_VER_LINUX: u32 = 1;
pub const _MKNOD_VER_LINUX: u32 = 0;
pub const _STAT_VER: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const HASHSLOTS: u32 = 256;
pub const _BOILERPLATE_OBSTACK_H: u32 = 1;
pub const REGISTRY_SHARED: u32 = 1;
pub const REGISTRY_ANON: u32 = 2;
pub const TM_INFINITE: u32 = 0;
pub const TM_NOW: u32 = 0;
pub const T_LOPRIO: u32 = 0;
pub const T_HIPRIO: u32 = 99;
pub const T_LOCK: u32 = 1;
pub const T_WARNSW: u32 = 2;
pub const T_CONFORMING: u32 = 4;
pub const T_JOINABLE: u32 = 65536;
pub const task_magic: u32 = 2189618155;
pub const Q_PRIO: u32 = 1;
pub const Q_FIFO: u32 = 0;
pub const Q_UNLIMITED: u32 = 0;
pub const Q_NORMAL: u32 = 0;
pub const Q_URGENT: u32 = 1;
pub const Q_BROADCAST: u32 = 2;
pub const queue_magic: u32 = 2273831915;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type size_t = ::std::os::raw::c_ulong;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn __cobalt_select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(
        __major: ::std::os::raw::c_uint,
        __minor: ::std::os::raw::c_uint,
    ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_ss_param {
    pub __sched_low_priority: ::std::os::raw::c_int,
    pub __sched_repl_period: timespec,
    pub __sched_init_budget: timespec,
    pub __sched_max_repl: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_ss_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_ss_param>(),
        48usize,
        concat!("Size of: ", stringify!(__sched_ss_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_ss_param>(),
        8usize,
        concat!("Alignment of ", stringify!(__sched_ss_param))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_ss_param>())).__sched_low_priority as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_ss_param),
            "::",
            stringify!(__sched_low_priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_ss_param>())).__sched_repl_period as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_ss_param),
            "::",
            stringify!(__sched_repl_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_ss_param>())).__sched_init_budget as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_ss_param),
            "::",
            stringify!(__sched_init_budget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_ss_param>())).__sched_max_repl as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_ss_param),
            "::",
            stringify!(__sched_max_repl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_rr_param {
    pub __sched_rr_quantum: timespec,
}
#[test]
fn bindgen_test_layout___sched_rr_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_rr_param>(),
        16usize,
        concat!("Size of: ", stringify!(__sched_rr_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_rr_param>(),
        8usize,
        concat!("Alignment of ", stringify!(__sched_rr_param))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_rr_param>())).__sched_rr_quantum as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_rr_param),
            "::",
            stringify!(__sched_rr_quantum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_tp_param {
    pub __sched_partition: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_tp_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_tp_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_tp_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_tp_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_tp_param))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_tp_param>())).__sched_partition as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_tp_param),
            "::",
            stringify!(__sched_partition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_tp_window {
    pub offset: timespec,
    pub duration: timespec,
    pub ptid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_tp_window() {
    assert_eq!(
        ::std::mem::size_of::<sched_tp_window>(),
        40usize,
        concat!("Size of: ", stringify!(sched_tp_window))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_tp_window>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_tp_window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_tp_window>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_tp_window),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_tp_window>())).duration as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_tp_window),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_tp_window>())).ptid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_tp_window),
            "::",
            stringify!(ptid)
        )
    );
}
pub const sched_tp_install: ::std::os::raw::c_uint = 0;
pub const sched_tp_uninstall: ::std::os::raw::c_uint = 1;
pub const sched_tp_start: ::std::os::raw::c_uint = 2;
pub const sched_tp_stop: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct __sched_config_tp {
    pub op: ::std::os::raw::c_int,
    pub nr_windows: ::std::os::raw::c_int,
    pub windows: __IncompleteArrayField<sched_tp_window>,
}
#[test]
fn bindgen_test_layout___sched_config_tp() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_tp>(),
        8usize,
        concat!("Size of: ", stringify!(__sched_config_tp))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_tp>(),
        8usize,
        concat!("Alignment of ", stringify!(__sched_config_tp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_config_tp>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_tp),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_config_tp>())).nr_windows as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_tp),
            "::",
            stringify!(nr_windows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_config_tp>())).windows as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_tp),
            "::",
            stringify!(windows)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_quota_param {
    pub __sched_group: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_quota_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_quota_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_quota_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_quota_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_quota_param))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_quota_param>())).__sched_group as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_quota_param),
            "::",
            stringify!(__sched_group)
        )
    );
}
pub const sched_quota_add: ::std::os::raw::c_uint = 0;
pub const sched_quota_remove: ::std::os::raw::c_uint = 1;
pub const sched_quota_force_remove: ::std::os::raw::c_uint = 2;
pub const sched_quota_set: ::std::os::raw::c_uint = 3;
pub const sched_quota_get: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sched_config_quota {
    pub op: ::std::os::raw::c_int,
    pub __bindgen_anon_1: __sched_config_quota__bindgen_ty_1,
    pub info: __sched_config_quota___sched_quota_info,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sched_config_quota__bindgen_ty_1 {
    pub add: __sched_config_quota__bindgen_ty_1__bindgen_ty_1,
    pub remove: __sched_config_quota__bindgen_ty_1__bindgen_ty_2,
    pub set: __sched_config_quota__bindgen_ty_1__bindgen_ty_3,
    pub get: __sched_config_quota__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u32; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_config_quota__bindgen_ty_1__bindgen_ty_1 {
    pub pshared: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_config_quota__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1__bindgen_ty_1>())).pshared
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pshared)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_config_quota__bindgen_ty_1__bindgen_ty_2 {
    pub tgid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_config_quota__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1__bindgen_ty_2>())).tgid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(tgid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_config_quota__bindgen_ty_1__bindgen_ty_3 {
    pub tgid: ::std::os::raw::c_int,
    pub quota: ::std::os::raw::c_int,
    pub quota_peak: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_config_quota__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1__bindgen_ty_3>())).tgid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tgid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1__bindgen_ty_3>())).quota
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(quota)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1__bindgen_ty_3>())).quota_peak
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(quota_peak)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_config_quota__bindgen_ty_1__bindgen_ty_4 {
    pub tgid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_config_quota__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1__bindgen_ty_4>())).tgid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(tgid)
        )
    );
}
#[test]
fn bindgen_test_layout___sched_config_quota__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(__sched_config_quota__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sched_config_quota__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1>())).add as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1>())).remove as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1>())).set as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota__bindgen_ty_1>())).get as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota__bindgen_ty_1),
            "::",
            stringify!(get)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_config_quota___sched_quota_info {
    pub tgid: ::std::os::raw::c_int,
    pub quota: ::std::os::raw::c_int,
    pub quota_peak: ::std::os::raw::c_int,
    pub quota_sum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_config_quota___sched_quota_info() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota___sched_quota_info>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(__sched_config_quota___sched_quota_info)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota___sched_quota_info>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__sched_config_quota___sched_quota_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota___sched_quota_info>())).tgid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota___sched_quota_info),
            "::",
            stringify!(tgid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota___sched_quota_info>())).quota as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota___sched_quota_info),
            "::",
            stringify!(quota)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota___sched_quota_info>())).quota_peak
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota___sched_quota_info),
            "::",
            stringify!(quota_peak)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__sched_config_quota___sched_quota_info>())).quota_sum
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota___sched_quota_info),
            "::",
            stringify!(quota_sum)
        )
    );
}
#[test]
fn bindgen_test_layout___sched_config_quota() {
    assert_eq!(
        ::std::mem::size_of::<__sched_config_quota>(),
        32usize,
        concat!("Size of: ", stringify!(__sched_config_quota))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_config_quota>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_config_quota))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_config_quota>())).op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_config_quota>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_config_quota),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param_ex {
    pub sched_priority: ::std::os::raw::c_int,
    pub sched_u: sched_param_ex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_param_ex__bindgen_ty_1 {
    pub ss: __sched_ss_param,
    pub rr: __sched_rr_param,
    pub tp: __sched_tp_param,
    pub quota: __sched_quota_param,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_sched_param_ex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sched_param_ex__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sched_param_ex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param_ex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_param_ex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param_ex__bindgen_ty_1>())).ss as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param_ex__bindgen_ty_1),
            "::",
            stringify!(ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param_ex__bindgen_ty_1>())).rr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param_ex__bindgen_ty_1),
            "::",
            stringify!(rr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param_ex__bindgen_ty_1>())).tp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param_ex__bindgen_ty_1),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sched_param_ex__bindgen_ty_1>())).quota as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param_ex__bindgen_ty_1),
            "::",
            stringify!(quota)
        )
    );
}
#[test]
fn bindgen_test_layout_sched_param_ex() {
    assert_eq!(
        ::std::mem::size_of::<sched_param_ex>(),
        56usize,
        concat!("Size of: ", stringify!(sched_param_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_param_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param_ex>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param_ex),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param_ex>())).sched_u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param_ex),
            "::",
            stringify!(sched_u)
        )
    );
}
#[repr(C)]
pub struct sched_config {
    pub tp: __BindgenUnionField<__sched_config_tp>,
    pub quota: __BindgenUnionField<__sched_config_quota>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_sched_config() {
    assert_eq!(
        ::std::mem::size_of::<sched_config>(),
        32usize,
        concat!("Size of: ", stringify!(sched_config))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_config>(),
        8usize,
        concat!("Alignment of ", stringify!(sched_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_config>())).tp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_config),
            "::",
            stringify!(tp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_config>())).quota as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_config),
            "::",
            stringify!(quota)
        )
    );
}
extern "C" {
    pub fn __cobalt_sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sched_get_priority_min(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sched_get_priority_min(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sched_get_priority_min(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sched_get_priority_max(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sched_get_priority_max(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sched_get_priority_max(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sched_setscheduler(
        pid: pid_t,
        policy: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sched_setscheduler(
        pid: pid_t,
        policy: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sched_setscheduler(
        pid: pid_t,
        policy: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sched_getscheduler(pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sched_getscheduler(pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sched_getscheduler(pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min_ex(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max_ex(policy: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler_ex(
        pid: pid_t,
        policy: ::std::os::raw::c_int,
        param_ex: *const sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler_ex(
        pid: pid_t,
        policy_r: *mut ::std::os::raw::c_int,
        param_ex: *mut sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setconfig_np(
        cpu: ::std::os::raw::c_int,
        policy: ::std::os::raw::c_int,
        config: *const sched_config,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getconfig_np(
        cpu: ::std::os::raw::c_int,
        policy: ::std::os::raw::c_int,
        config: *mut sched_config,
        len_r: *mut size_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: ::std::os::raw::c_int,
        __value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_destroy(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_open(
        __name: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_close(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_wait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_trywait(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_post(__sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_getvalue(
        __sem: *mut sem_t,
        __sval: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_t {
    pub v: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_atomic_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(atomic_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(atomic_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_t),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_long_t {
    pub v: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_atomic_long_t() {
    assert_eq!(
        ::std::mem::size_of::<atomic_long_t>(),
        8usize,
        concat!("Size of: ", stringify!(atomic_long_t))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_long_t>(),
        8usize,
        concat!("Alignment of ", stringify!(atomic_long_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<atomic_long_t>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_long_t),
            "::",
            stringify!(v)
        )
    );
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type xnticks_t = __u64;
pub type xnsticks_t = __s64;
pub type xnhandle_t = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_sem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_sem_state {
    pub value: atomic_t,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_cobalt_sem_state() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_sem_state>(),
        8usize,
        concat!("Size of: ", stringify!(cobalt_sem_state))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_sem_state>(),
        4usize,
        concat!("Alignment of ", stringify!(cobalt_sem_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_state>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_state),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_state>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_state),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cobalt_sem_union {
    pub native_sem: sem_t,
    pub shadow_sem: cobalt_sem_union_cobalt_sem_shadow,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_sem_union_cobalt_sem_shadow {
    pub magic: __u32,
    pub state_offset: __s32,
    pub handle: xnhandle_t,
}
#[test]
fn bindgen_test_layout_cobalt_sem_union_cobalt_sem_shadow() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_sem_union_cobalt_sem_shadow>(),
        12usize,
        concat!("Size of: ", stringify!(cobalt_sem_union_cobalt_sem_shadow))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_sem_union_cobalt_sem_shadow>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cobalt_sem_union_cobalt_sem_shadow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cobalt_sem_union_cobalt_sem_shadow>())).magic as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_union_cobalt_sem_shadow),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cobalt_sem_union_cobalt_sem_shadow>())).state_offset as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_union_cobalt_sem_shadow),
            "::",
            stringify!(state_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cobalt_sem_union_cobalt_sem_shadow>())).handle as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_union_cobalt_sem_shadow),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout_cobalt_sem_union() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_sem_union>(),
        32usize,
        concat!("Size of: ", stringify!(cobalt_sem_union))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_sem_union>(),
        8usize,
        concat!("Alignment of ", stringify!(cobalt_sem_union))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_union>())).native_sem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_union),
            "::",
            stringify!(native_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_union>())).shadow_sem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_union),
            "::",
            stringify!(shadow_sem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_sem_info {
    pub value: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_int,
    pub nrwait: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cobalt_sem_info() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_sem_info>(),
        12usize,
        concat!("Size of: ", stringify!(cobalt_sem_info))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_sem_info>(),
        4usize,
        concat!("Alignment of ", stringify!(cobalt_sem_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_info>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_info),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_info>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_sem_info>())).nrwait as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_sem_info),
            "::",
            stringify!(nrwait)
        )
    );
}
extern "C" {
    pub fn __cobalt_sem_init(
        sem: *mut sem_t,
        pshared: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_init(
        sem: *mut sem_t,
        pshared: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_init(
        sem: *mut sem_t,
        pshared: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_destroy(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_destroy(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_destroy(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_post(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_post(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_post(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_wait(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_wait(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_wait(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_timedwait(
        sem: *mut sem_t,
        abs_timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_timedwait(
        sem: *mut sem_t,
        abs_timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_timedwait(
        sem: *mut sem_t,
        abs_timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_trywait(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_trywait(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_trywait(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_getvalue(
        sem: *mut sem_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_getvalue(
        sem: *mut sem_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_getvalue(
        sem: *mut sem_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_open(
        name: *const ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn __real_sem_open(
        name: *const ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn __wrap_sem_open(
        name: *const ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn __cobalt_sem_close(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_close(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_close(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sem_unlink(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sem_unlink(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sem_unlink(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_init_np(
        sem: *mut sem_t,
        flags: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_broadcast_np(sem: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type memoff_t = usize;
extern "C" {
    pub static mut __main_heap: *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pshared_check(
        heap: *mut ::std::os::raw::c_void,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct holder {
    pub next: memoff_t,
    pub prev: memoff_t,
}
#[test]
fn bindgen_test_layout_holder() {
    assert_eq!(
        ::std::mem::size_of::<holder>(),
        16usize,
        concat!("Size of: ", stringify!(holder))
    );
    assert_eq!(
        ::std::mem::align_of::<holder>(),
        8usize,
        concat!("Alignment of ", stringify!(holder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<holder>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(holder),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<holder>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(holder),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct listobj {
    pub head: holder,
}
#[test]
fn bindgen_test_layout_listobj() {
    assert_eq!(
        ::std::mem::size_of::<listobj>(),
        16usize,
        concat!("Size of: ", stringify!(listobj))
    );
    assert_eq!(
        ::std::mem::align_of::<listobj>(),
        8usize,
        concat!("Alignment of ", stringify!(listobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<listobj>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(listobj),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvholder {
    pub next: *mut pvholder,
    pub prev: *mut pvholder,
}
#[test]
fn bindgen_test_layout_pvholder() {
    assert_eq!(
        ::std::mem::size_of::<pvholder>(),
        16usize,
        concat!("Size of: ", stringify!(pvholder))
    );
    assert_eq!(
        ::std::mem::align_of::<pvholder>(),
        8usize,
        concat!("Alignment of ", stringify!(pvholder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvholder>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvholder),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvholder>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pvholder),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvlistobj {
    pub head: pvholder,
}
#[test]
fn bindgen_test_layout_pvlistobj() {
    assert_eq!(
        ::std::mem::size_of::<pvlistobj>(),
        16usize,
        concat!("Size of: ", stringify!(pvlistobj))
    );
    assert_eq!(
        ::std::mem::align_of::<pvlistobj>(),
        8usize,
        concat!("Alignment of ", stringify!(pvlistobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvlistobj>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvlistobj),
            "::",
            stringify!(head)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __cobalt_clock_getres(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_clock_getres(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_clock_getres(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_clock_settime(
        clock_id: clockid_t,
        tp: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_clock_adjtime(clock_id: clockid_t, tx: *mut timex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_clock_adjtime(clock_id: clockid_t, tx: *mut timex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_clock_adjtime(clock_id: clockid_t, tx: *mut timex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_clock_nanosleep(
        clock_id: clockid_t,
        flags: ::std::os::raw::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_clock_nanosleep(
        clock_id: clockid_t,
        flags: ::std::os::raw::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_clock_nanosleep(
        clock_id: clockid_t,
        flags: ::std::os::raw::c_int,
        rqtp: *const timespec,
        rmtp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_time(t: *mut time_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __real_time(t: *mut time_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __wrap_time(t: *mut time_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __cobalt_nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_timer_create(
        clockid: clockid_t,
        evp: *const sigevent,
        timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_timer_create(
        clockid: clockid_t,
        evp: *const sigevent,
        timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_timer_create(
        clockid: clockid_t,
        evp: *const sigevent,
        timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_timer_delete(timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_timer_delete(timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_timer_delete(timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_timer_settime(
        timerid: timer_t,
        flags: ::std::os::raw::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_timer_settime(
        timerid: timer_t,
        flags: ::std::os::raw::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_timer_settime(
        timerid: timer_t,
        flags: ::std::os::raw::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_timer_gettime(
        timerid: timer_t,
        value: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_timer_getoverrun(timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_timer_getoverrun(timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_timer_getoverrun(timerid: timer_t) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::std::os::raw::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xnthread_user_window {
    pub state: __u32,
    pub info: __u32,
    pub grant_value: __u32,
    pub pp_pending: __u32,
}
#[test]
fn bindgen_test_layout_xnthread_user_window() {
    assert_eq!(
        ::std::mem::size_of::<xnthread_user_window>(),
        16usize,
        concat!("Size of: ", stringify!(xnthread_user_window))
    );
    assert_eq!(
        ::std::mem::align_of::<xnthread_user_window>(),
        4usize,
        concat!("Alignment of ", stringify!(xnthread_user_window))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xnthread_user_window>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xnthread_user_window),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xnthread_user_window>())).info as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xnthread_user_window),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xnthread_user_window>())).grant_value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xnthread_user_window),
            "::",
            stringify!(grant_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xnthread_user_window>())).pp_pending as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xnthread_user_window),
            "::",
            stringify!(pp_pending)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_mutexattr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_cobalt_mutexattr() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_mutexattr>(),
        4usize,
        concat!("Size of: ", stringify!(cobalt_mutexattr))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_mutexattr>(),
        4usize,
        concat!("Alignment of ", stringify!(cobalt_mutexattr))
    );
}
impl cobalt_mutexattr {
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn protocol(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_protocol(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pshared(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pshared(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pad(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___pad(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ceiling(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ceiling(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
        pshared: ::std::os::raw::c_int,
        __pad: ::std::os::raw::c_int,
        ceiling: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let protocol: u32 = unsafe { ::std::mem::transmute(protocol) };
            protocol as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pshared: u32 = unsafe { ::std::mem::transmute(pshared) };
            pshared as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __pad: u32 = unsafe { ::std::mem::transmute(__pad) };
            __pad as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let ceiling: u32 = unsafe { ::std::mem::transmute(ceiling) };
            ceiling as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_condattr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_cobalt_condattr() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_condattr>(),
        4usize,
        concat!("Size of: ", stringify!(cobalt_condattr))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_condattr>(),
        4usize,
        concat!("Alignment of ", stringify!(cobalt_condattr))
    );
}
impl cobalt_condattr {
    #[inline]
    pub fn clock(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_clock(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn pshared(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pshared(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        clock: ::std::os::raw::c_int,
        pshared: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let clock: u32 = unsafe { ::std::mem::transmute(clock) };
            clock as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pshared: u32 = unsafe { ::std::mem::transmute(pshared) };
            pshared as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_threadstat {
    pub xtime: __u64,
    pub timeout: __u64,
    pub msw: __u64,
    pub csw: __u64,
    pub xsc: __u64,
    pub status: __u32,
    pub pf: __u32,
    pub cpu: ::std::os::raw::c_int,
    pub cprio: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 32usize],
    pub personality: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_cobalt_threadstat() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_threadstat>(),
        120usize,
        concat!("Size of: ", stringify!(cobalt_threadstat))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_threadstat>(),
        8usize,
        concat!("Alignment of ", stringify!(cobalt_threadstat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).xtime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(xtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).timeout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).msw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(msw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).csw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(csw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).xsc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(xsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).status as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).pf as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(pf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).cpu as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).cprio as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(cprio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_threadstat>())).personality as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_threadstat),
            "::",
            stringify!(personality)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_ex {
    pub std: pthread_attr_t,
    pub nonstd: pthread_attr_ex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_attr_ex__bindgen_ty_1 {
    pub personality: ::std::os::raw::c_int,
    pub sched_policy: ::std::os::raw::c_int,
    pub sched_param: sched_param_ex,
}
#[test]
fn bindgen_test_layout_pthread_attr_ex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_ex__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(pthread_attr_ex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_ex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_ex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_attr_ex__bindgen_ty_1>())).personality as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_ex__bindgen_ty_1),
            "::",
            stringify!(personality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_attr_ex__bindgen_ty_1>())).sched_policy as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_ex__bindgen_ty_1),
            "::",
            stringify!(sched_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_attr_ex__bindgen_ty_1>())).sched_param as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_ex__bindgen_ty_1),
            "::",
            stringify!(sched_param)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_ex>(),
        120usize,
        concat!("Size of: ", stringify!(pthread_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_ex>())).std as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_ex),
            "::",
            stringify!(std)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_ex>())).nonstd as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_ex),
            "::",
            stringify!(nonstd)
        )
    );
}
pub type pthread_attr_ex_t = pthread_attr_ex;
extern "C" {
    pub fn __cobalt_pthread_attr_init(attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_attr_init(attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_attr_init(attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_create(
        ptid_r: *mut pthread_t,
        attr: *const pthread_attr_t,
        start: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_create(
        ptid_r: *mut pthread_t,
        attr: *const pthread_attr_t,
        start: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_create(
        ptid_r: *mut pthread_t,
        attr: *const pthread_attr_t,
        start: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_getschedparam(
        thread: pthread_t,
        policy: *mut ::std::os::raw::c_int,
        param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_getschedparam(
        thread: pthread_t,
        policy: *mut ::std::os::raw::c_int,
        param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_getschedparam(
        thread: pthread_t,
        policy: *mut ::std::os::raw::c_int,
        param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_setschedparam(
        thread: pthread_t,
        policy: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_setschedparam(
        thread: pthread_t,
        policy: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_setschedparam(
        thread: pthread_t,
        policy: ::std::os::raw::c_int,
        param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_setschedprio(
        thread: pthread_t,
        prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_setschedprio(
        thread: pthread_t,
        prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_setschedprio(
        thread: pthread_t,
        prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_init(
        mutex: *mut pthread_mutex_t,
        attr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_init(
        mutex: *mut pthread_mutex_t,
        attr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_init(
        mutex: *mut pthread_mutex_t,
        attr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_timedlock(
        mutex: *mut pthread_mutex_t,
        to: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_timedlock(
        mutex: *mut pthread_mutex_t,
        to: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_timedlock(
        mutex: *mut pthread_mutex_t,
        to: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_trylock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_trylock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_trylock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_setprioceiling(
        mutex: *mut pthread_mutex_t,
        prioceiling: ::std::os::raw::c_int,
        old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_setprioceiling(
        mutex: *mut pthread_mutex_t,
        prioceiling: ::std::os::raw::c_int,
        old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_setprioceiling(
        mutex: *mut pthread_mutex_t,
        prioceiling: ::std::os::raw::c_int,
        old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_mutex_getprioceiling(
        mutex: *mut pthread_mutex_t,
        old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_mutex_getprioceiling(
        mutex: *mut pthread_mutex_t,
        old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_mutex_getprioceiling(
        mutex: *mut pthread_mutex_t,
        old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_cond_init(
        cond: *mut pthread_cond_t,
        attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_cond_init(
        cond: *mut pthread_cond_t,
        attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_cond_init(
        cond: *mut pthread_cond_t,
        attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_cond_destroy(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_cond_wait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_cond_wait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_cond_wait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_cond_timedwait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
        abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_cond_timedwait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
        abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_cond_timedwait(
        cond: *mut pthread_cond_t,
        mutex: *mut pthread_mutex_t,
        abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_cond_signal(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_cond_signal(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_cond_signal(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_cond_broadcast(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_cond_broadcast(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_cond_broadcast(cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_kill(
        ptid: pthread_t,
        sig: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_kill(
        ptid: pthread_t,
        sig: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_kill(
        ptid: pthread_t,
        sig: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_join(
        ptid: pthread_t,
        retval: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_join(
        ptid: pthread_t,
        retval: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_join(
        ptid: pthread_t,
        retval: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setmode_np(
        clrmask: ::std::os::raw::c_int,
        setmask: ::std::os::raw::c_int,
        mask_r: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_pthread_setname_np(
        thread: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_pthread_setname_np(
        thread: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_pthread_setname_np(
        thread: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_ex(
        ptid_r: *mut pthread_t,
        attr_ex: *const pthread_attr_ex_t,
        start: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam_ex(
        ptid: pthread_t,
        pol: *mut ::std::os::raw::c_int,
        par: *mut sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam_ex(
        ptid: pthread_t,
        pol: ::std::os::raw::c_int,
        par: *const sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init_ex(attr_ex: *mut pthread_attr_ex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy_ex(attr_ex: *mut pthread_attr_ex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy_ex(
        attr_ex: *mut pthread_attr_ex_t,
        policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy_ex(
        attr_ex: *const pthread_attr_ex_t,
        policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam_ex(
        attr_ex: *mut pthread_attr_ex_t,
        param_ex: *const sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam_ex(
        attr_ex: *const pthread_attr_ex_t,
        param_ex: *mut sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched_ex(
        attr_ex: *const pthread_attr_ex_t,
        inheritsched: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched_ex(
        attr_ex: *mut pthread_attr_ex_t,
        inheritsched: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate_ex(
        attr_ex: *const pthread_attr_ex_t,
        detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate_ex(
        attr_ex: *mut pthread_attr_ex_t,
        detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize_ex(
        attr_ex: *const pthread_attr_ex_t,
        stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize_ex(
        attr_ex: *mut pthread_attr_ex_t,
        stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope_ex(
        attr_ex: *const pthread_attr_ex_t,
        scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope_ex(
        attr_ex: *mut pthread_attr_ex_t,
        scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getpersonality_ex(
        attr_ex: *const pthread_attr_ex_t,
        personality: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setpersonality_ex(
        attr_ex: *mut pthread_attr_ex_t,
        personality: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct backtrace_data {}
#[test]
fn bindgen_test_layout_backtrace_data() {
    assert_eq!(
        ::std::mem::size_of::<backtrace_data>(),
        0usize,
        concat!("Size of: ", stringify!(backtrace_data))
    );
    assert_eq!(
        ::std::mem::align_of::<backtrace_data>(),
        1usize,
        concat!("Alignment of ", stringify!(backtrace_data))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service {
    pub cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_service() {
    assert_eq!(
        ::std::mem::size_of::<service>(),
        4usize,
        concat!("Size of: ", stringify!(service))
    );
    assert_eq!(
        ::std::mem::align_of::<service>(),
        4usize,
        concat!("Alignment of ", stringify!(service))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<service>())).cancel_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(service),
            "::",
            stringify!(cancel_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cleanup_block {
    pub lock: *mut pthread_mutex_t,
    pub handler: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_cleanup_block() {
    assert_eq!(
        ::std::mem::size_of::<cleanup_block>(),
        24usize,
        concat!("Size of: ", stringify!(cleanup_block))
    );
    assert_eq!(
        ::std::mem::align_of::<cleanup_block>(),
        8usize,
        concat!("Alignment of ", stringify!(cleanup_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cleanup_block>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cleanup_block),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cleanup_block>())).handler as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cleanup_block),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cleanup_block>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cleanup_block),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn __run_cleanup_block(cb: *mut cleanup_block);
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct base_setup_data {
    pub cpu_affinity: cpu_set_t,
    pub no_mlock: ::std::os::raw::c_int,
    pub no_sanity: ::std::os::raw::c_int,
    pub verbosity_level: ::std::os::raw::c_int,
    pub trace_level: ::std::os::raw::c_int,
    pub arg0: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_base_setup_data() {
    assert_eq!(
        ::std::mem::size_of::<base_setup_data>(),
        152usize,
        concat!("Size of: ", stringify!(base_setup_data))
    );
    assert_eq!(
        ::std::mem::align_of::<base_setup_data>(),
        8usize,
        concat!("Alignment of ", stringify!(base_setup_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_setup_data>())).cpu_affinity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(base_setup_data),
            "::",
            stringify!(cpu_affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_setup_data>())).no_mlock as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(base_setup_data),
            "::",
            stringify!(no_mlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_setup_data>())).no_sanity as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(base_setup_data),
            "::",
            stringify!(no_sanity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_setup_data>())).verbosity_level as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(base_setup_data),
            "::",
            stringify!(verbosity_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_setup_data>())).trace_level as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(base_setup_data),
            "::",
            stringify!(trace_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<base_setup_data>())).arg0 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(base_setup_data),
            "::",
            stringify!(arg0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct setup_descriptor {
    pub name: *const ::std::os::raw::c_char,
    pub tune: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub parse_option: ::std::option::Option<
        unsafe extern "C" fn(
            optnum: ::std::os::raw::c_int,
            optarg: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub help: ::std::option::Option<unsafe extern "C" fn()>,
    pub init: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub options: *const option,
    pub __reserved: setup_descriptor__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct setup_descriptor__bindgen_ty_1 {
    pub id: ::std::os::raw::c_int,
    pub opt_start: ::std::os::raw::c_int,
    pub opt_end: ::std::os::raw::c_int,
    pub next: pvholder,
    pub done: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_setup_descriptor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<setup_descriptor__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(setup_descriptor__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_descriptor__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_descriptor__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_descriptor__bindgen_ty_1>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_descriptor__bindgen_ty_1>())).opt_start as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor__bindgen_ty_1),
            "::",
            stringify!(opt_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_descriptor__bindgen_ty_1>())).opt_end as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor__bindgen_ty_1),
            "::",
            stringify!(opt_end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_descriptor__bindgen_ty_1>())).next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<setup_descriptor__bindgen_ty_1>())).done as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor__bindgen_ty_1),
            "::",
            stringify!(done)
        )
    );
}
#[test]
fn bindgen_test_layout_setup_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<setup_descriptor>(),
        88usize,
        concat!("Size of: ", stringify!(setup_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<setup_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(setup_descriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).tune as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(tune)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).parse_option as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(parse_option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).help as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).options as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<setup_descriptor>())).__reserved as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(setup_descriptor),
            "::",
            stringify!(__reserved)
        )
    );
}
extern "C" {
    pub fn __register_setup_call(p: *mut setup_descriptor, id: ::std::os::raw::c_int);
}
extern "C" {
    pub static mut __node_id: pid_t;
}
extern "C" {
    pub static mut __config_done: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __base_setup_data: base_setup_data;
}
extern "C" {
    pub fn get_program_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __trace_me(fmt: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fnref {
    pub fn_: ::std::option::Option<unsafe extern "C" fn()>,
    pub hash: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___fnref() {
    assert_eq!(
        ::std::mem::size_of::<__fnref>(),
        16usize,
        concat!("Size of: ", stringify!(__fnref))
    );
    assert_eq!(
        ::std::mem::align_of::<__fnref>(),
        8usize,
        concat!("Alignment of ", stringify!(__fnref))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fnref>())).fn_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fnref),
            "::",
            stringify!(fn_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fnref>())).hash as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__fnref),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    pub static mut __fnrefs: [[__fnref; 16usize]; 16usize];
}
extern "C" {
    pub fn __fnref_register(
        libname: *const ::std::os::raw::c_char,
        libtag: ::std::os::raw::c_int,
        cbirev: ::std::os::raw::c_int,
        symname: *const ::std::os::raw::c_char,
        fn_: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syncstate {
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_syncstate() {
    assert_eq!(
        ::std::mem::size_of::<syncstate>(),
        4usize,
        concat!("Size of: ", stringify!(syncstate))
    );
    assert_eq!(
        ::std::mem::align_of::<syncstate>(),
        4usize,
        concat!("Alignment of ", stringify!(syncstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncstate>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syncstate),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_monitor_state {
    pub owner: atomic_t,
    pub flags: __u32,
}
#[test]
fn bindgen_test_layout_cobalt_monitor_state() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_monitor_state>(),
        8usize,
        concat!("Size of: ", stringify!(cobalt_monitor_state))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_monitor_state>(),
        4usize,
        concat!("Alignment of ", stringify!(cobalt_monitor_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_monitor_state>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_monitor_state),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_monitor_state>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_monitor_state),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_monitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cobalt_monitor_shadow {
    pub state_offset: __u32,
    pub flags: __u32,
    pub handle: xnhandle_t,
}
#[test]
fn bindgen_test_layout_cobalt_monitor_shadow() {
    assert_eq!(
        ::std::mem::size_of::<cobalt_monitor_shadow>(),
        12usize,
        concat!("Size of: ", stringify!(cobalt_monitor_shadow))
    );
    assert_eq!(
        ::std::mem::align_of::<cobalt_monitor_shadow>(),
        4usize,
        concat!("Alignment of ", stringify!(cobalt_monitor_shadow))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<cobalt_monitor_shadow>())).state_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_monitor_shadow),
            "::",
            stringify!(state_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_monitor_shadow>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_monitor_shadow),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cobalt_monitor_shadow>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cobalt_monitor_shadow),
            "::",
            stringify!(handle)
        )
    );
}
pub type cobalt_monitor_t = cobalt_monitor_shadow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syncobj_corespec {
    pub monitor: cobalt_monitor_t,
}
#[test]
fn bindgen_test_layout_syncobj_corespec() {
    assert_eq!(
        ::std::mem::size_of::<syncobj_corespec>(),
        12usize,
        concat!("Size of: ", stringify!(syncobj_corespec))
    );
    assert_eq!(
        ::std::mem::align_of::<syncobj_corespec>(),
        4usize,
        concat!("Alignment of ", stringify!(syncobj_corespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj_corespec>())).monitor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj_corespec),
            "::",
            stringify!(monitor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syncobj {
    pub magic: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_int,
    pub wait_count: ::std::os::raw::c_int,
    pub grant_list: listobj,
    pub grant_count: ::std::os::raw::c_int,
    pub drain_list: listobj,
    pub drain_count: ::std::os::raw::c_int,
    pub core: syncobj_corespec,
    pub finalizer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_syncobj() {
    assert_eq!(
        ::std::mem::size_of::<syncobj>(),
        80usize,
        concat!("Size of: ", stringify!(syncobj))
    );
    assert_eq!(
        ::std::mem::align_of::<syncobj>(),
        8usize,
        concat!("Alignment of ", stringify!(syncobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).wait_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(wait_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).grant_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(grant_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).grant_count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(grant_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).drain_list as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(drain_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).drain_count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(drain_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).core as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(core)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncobj>())).finalizer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(syncobj),
            "::",
            stringify!(finalizer)
        )
    );
}
extern "C" {
    pub fn __syncobj_cleanup_wait(sobj: *mut syncobj, thobj: *mut threadobj);
}
extern "C" {
    pub fn __syncobj_broadcast_drain(
        sobj: *mut syncobj,
        reason: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __syncobj_broadcast_grant(
        sobj: *mut syncobj,
        reason: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncobj_init(
        sobj: *mut syncobj,
        clk_id: clockid_t,
        flags: ::std::os::raw::c_int,
        finalizer: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncobj_wait_grant(
        sobj: *mut syncobj,
        timeout: *const timespec,
        syns: *mut syncstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncobj_grant_one(sobj: *mut syncobj) -> *mut threadobj;
}
extern "C" {
    pub fn syncobj_grant_to(sobj: *mut syncobj, thobj: *mut threadobj);
}
extern "C" {
    pub fn syncobj_peek_grant(sobj: *mut syncobj) -> *mut threadobj;
}
extern "C" {
    pub fn syncobj_peek_drain(sobj: *mut syncobj) -> *mut threadobj;
}
extern "C" {
    pub fn syncobj_lock(sobj: *mut syncobj, syns: *mut syncstate) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncobj_unlock(sobj: *mut syncobj, syns: *mut syncstate);
}
extern "C" {
    pub fn syncobj_wait_drain(
        sobj: *mut syncobj,
        timeout: *const timespec,
        syns: *mut syncstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncobj_destroy(sobj: *mut syncobj, syns: *mut syncstate) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncobj_uninit(sobj: *mut syncobj);
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._lower as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._upper as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                ._addr_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()))._bounds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>())).__pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: ::std::os::raw::c_int = -60;
pub const SI_TKILL: ::std::os::raw::c_int = -6;
pub const SI_SIGIO: ::std::os::raw::c_int = -5;
pub const SI_ASYNCIO: ::std::os::raw::c_int = -4;
pub const SI_MESGQ: ::std::os::raw::c_int = -3;
pub const SI_TIMER: ::std::os::raw::c_int = -2;
pub const SI_QUEUE: ::std::os::raw::c_int = -1;
pub const SI_USER: ::std::os::raw::c_int = 0;
pub const SI_KERNEL: ::std::os::raw::c_int = 128;
pub type _bindgen_ty_13 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: ::std::os::raw::c_uint = 1;
pub const ILL_ILLOPN: ::std::os::raw::c_uint = 2;
pub const ILL_ILLADR: ::std::os::raw::c_uint = 3;
pub const ILL_ILLTRP: ::std::os::raw::c_uint = 4;
pub const ILL_PRVOPC: ::std::os::raw::c_uint = 5;
pub const ILL_PRVREG: ::std::os::raw::c_uint = 6;
pub const ILL_COPROC: ::std::os::raw::c_uint = 7;
pub const ILL_BADSTK: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: ::std::os::raw::c_uint = 1;
pub const FPE_INTOVF: ::std::os::raw::c_uint = 2;
pub const FPE_FLTDIV: ::std::os::raw::c_uint = 3;
pub const FPE_FLTOVF: ::std::os::raw::c_uint = 4;
pub const FPE_FLTUND: ::std::os::raw::c_uint = 5;
pub const FPE_FLTRES: ::std::os::raw::c_uint = 6;
pub const FPE_FLTINV: ::std::os::raw::c_uint = 7;
pub const FPE_FLTSUB: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: ::std::os::raw::c_uint = 1;
pub const SEGV_ACCERR: ::std::os::raw::c_uint = 2;
pub const SEGV_BNDERR: ::std::os::raw::c_uint = 3;
pub const SEGV_PKUERR: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: ::std::os::raw::c_uint = 1;
pub const BUS_ADRERR: ::std::os::raw::c_uint = 2;
pub const BUS_OBJERR: ::std::os::raw::c_uint = 3;
pub const BUS_MCEERR_AR: ::std::os::raw::c_uint = 4;
pub const BUS_MCEERR_AO: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const CLD_EXITED: ::std::os::raw::c_uint = 1;
pub const CLD_KILLED: ::std::os::raw::c_uint = 2;
pub const CLD_DUMPED: ::std::os::raw::c_uint = 3;
pub const CLD_TRAPPED: ::std::os::raw::c_uint = 4;
pub const CLD_STOPPED: ::std::os::raw::c_uint = 5;
pub const CLD_CONTINUED: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const POLL_IN: ::std::os::raw::c_uint = 1;
pub const POLL_OUT: ::std::os::raw::c_uint = 2;
pub const POLL_MSG: ::std::os::raw::c_uint = 3;
pub const POLL_ERR: ::std::os::raw::c_uint = 4;
pub const POLL_PRI: ::std::os::raw::c_uint = 5;
pub const POLL_HUP: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: ::std::os::raw::c_uint = 0;
pub const SIGEV_NONE: ::std::os::raw::c_uint = 1;
pub const SIGEV_THREAD: ::std::os::raw::c_uint = 2;
pub const SIGEV_THREAD_ID: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).__glibc_reserved1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).__glibc_reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stack_t>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        936usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucontext_t>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: ::std::os::raw::c_uint = 1;
pub const SS_DISABLE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cobalt_sigshadow_handler(
        sig: ::std::os::raw::c_int,
        si: *mut siginfo_t,
        ctxt: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cobalt_sigdebug_handler(
        sig: ::std::os::raw::c_int,
        si: *mut siginfo_t,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __cobalt_sigpending(set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sigpending(set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sigpending(set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sigwait(
        set: *const sigset_t,
        sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sigwait(
        set: *const sigset_t,
        sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sigwait(
        set: *const sigset_t,
        sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sigwaitinfo(set: *const sigset_t, si: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sigwaitinfo(set: *const sigset_t, si: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sigwaitinfo(set: *const sigset_t, si: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sigtimedwait(
        set: *const sigset_t,
        si: *mut siginfo_t,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sigtimedwait(
        set: *const sigset_t,
        si: *mut siginfo_t,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sigtimedwait(
        set: *const sigset_t,
        si: *mut siginfo_t,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_kill(pid: pid_t, sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_kill(pid: pid_t, sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_kill(pid: pid_t, sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_sigqueue(
        pid: pid_t,
        sig: ::std::os::raw::c_int,
        value: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_sigqueue(
        pid: pid_t,
        sig: ::std::os::raw::c_int,
        value: sigval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_sigqueue(
        pid: pid_t,
        sig: ::std::os::raw::c_int,
        value: sigval,
    ) -> ::std::os::raw::c_int;
}
pub type ticks_t = ::std::os::raw::c_ulonglong;
pub type sticks_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn timespec_sub(r: *mut timespec, t1: *const timespec, t2: *const timespec);
}
extern "C" {
    pub fn timespec_subs(r: *mut timespec, t1: *const timespec, t2: sticks_t);
}
extern "C" {
    pub fn timespec_add(r: *mut timespec, t1: *const timespec, t2: *const timespec);
}
extern "C" {
    pub fn timespec_adds(r: *mut timespec, t1: *const timespec, t2: sticks_t);
}
extern "C" {
    pub fn timespec_sets(r: *mut timespec, ns: ticks_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clockobj {
    pub lock: pthread_mutex_t,
    pub epoch: timespec,
    pub offset: timespec,
}
#[test]
fn bindgen_test_layout_clockobj() {
    assert_eq!(
        ::std::mem::size_of::<clockobj>(),
        72usize,
        concat!("Size of: ", stringify!(clockobj))
    );
    assert_eq!(
        ::std::mem::align_of::<clockobj>(),
        8usize,
        concat!("Alignment of ", stringify!(clockobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockobj>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockobj),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockobj>())).epoch as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(clockobj),
            "::",
            stringify!(epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clockobj>())).offset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(clockobj),
            "::",
            stringify!(offset)
        )
    );
}
extern "C" {
    pub fn clockobj_set_date(clkobj: *mut clockobj, ticks: ticks_t);
}
extern "C" {
    pub fn clockobj_get_date(clkobj: *mut clockobj, pticks: *mut ticks_t);
}
extern "C" {
    pub fn clockobj_get_time(clkobj: *mut clockobj) -> ticks_t;
}
extern "C" {
    pub fn clockobj_get_distance(
        clkobj: *mut clockobj,
        itm: *const itimerspec,
        delta: *mut timespec,
    );
}
extern "C" {
    pub fn clockobj_get_tsc() -> ticks_t;
}
extern "C" {
    pub fn clockobj_caltime_to_timeout(
        clkobj: *mut clockobj,
        tm: *const tm,
        rticks: ::std::os::raw::c_ulong,
        ts: *mut timespec,
    );
}
extern "C" {
    pub fn clockobj_caltime_to_ticks(
        clkobj: *mut clockobj,
        tm: *const tm,
        rticks: ::std::os::raw::c_ulong,
        pticks: *mut ticks_t,
    );
}
extern "C" {
    pub fn clockobj_ticks_to_caltime(
        clkobj: *mut clockobj,
        ticks: ticks_t,
        tm: *mut tm,
        rticks: *mut ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn clockobj_convert_clocks(
        clkobj: *mut clockobj,
        in_: *const timespec,
        clk_id: clockid_t,
        out: *mut timespec,
    );
}
extern "C" {
    pub fn clockobj_set_resolution(
        clkobj: *mut clockobj,
        resolution_ns: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clockobj_init(
        clkobj: *mut clockobj,
        resolution_ns: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clockobj_destroy(clkobj: *mut clockobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cobalt_read_hrclock() -> xnticks_t;
}
extern "C" {
    pub fn cobalt_ticks_to_ns(ticks: xnsticks_t) -> xnsticks_t;
}
extern "C" {
    pub fn cobalt_ticks_to_ns_rounded(ticks: xnsticks_t) -> xnsticks_t;
}
extern "C" {
    pub fn cobalt_ns_to_ticks(ns: xnsticks_t) -> xnsticks_t;
}
extern "C" {
    pub fn cobalt_divrem_billion(
        value: ::std::os::raw::c_ulonglong,
        rem: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct heapobj {
    pub __bindgen_anon_1: heapobj__bindgen_ty_1,
    pub size: size_t,
    pub name: [::std::os::raw::c_char; 32usize],
    pub fsname: [::std::os::raw::c_char; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union heapobj__bindgen_ty_1 {
    pub pool_ref: memoff_t,
    pub pool: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_heapobj__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<heapobj__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(heapobj__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<heapobj__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(heapobj__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapobj__bindgen_ty_1>())).pool_ref as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heapobj__bindgen_ty_1),
            "::",
            stringify!(pool_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapobj__bindgen_ty_1>())).pool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heapobj__bindgen_ty_1),
            "::",
            stringify!(pool)
        )
    );
}
#[test]
fn bindgen_test_layout_heapobj() {
    assert_eq!(
        ::std::mem::size_of::<heapobj>(),
        304usize,
        concat!("Size of: ", stringify!(heapobj))
    );
    assert_eq!(
        ::std::mem::align_of::<heapobj>(),
        8usize,
        concat!("Alignment of ", stringify!(heapobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapobj>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(heapobj),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapobj>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heapobj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapobj>())).fsname as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(heapobj),
            "::",
            stringify!(fsname)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysgroup {
    pub thread_count: ::std::os::raw::c_int,
    pub thread_list: listobj,
    pub heap_count: ::std::os::raw::c_int,
    pub heap_list: listobj,
    pub lock: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_sysgroup() {
    assert_eq!(
        ::std::mem::size_of::<sysgroup>(),
        88usize,
        concat!("Size of: ", stringify!(sysgroup))
    );
    assert_eq!(
        ::std::mem::align_of::<sysgroup>(),
        8usize,
        concat!("Alignment of ", stringify!(sysgroup))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysgroup>())).thread_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysgroup),
            "::",
            stringify!(thread_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysgroup>())).thread_list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysgroup),
            "::",
            stringify!(thread_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysgroup>())).heap_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sysgroup),
            "::",
            stringify!(heap_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysgroup>())).heap_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sysgroup),
            "::",
            stringify!(heap_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysgroup>())).lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sysgroup),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    pub fn heapobj_pkg_init_private() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __heapobj_init_private(
        hobj: *mut heapobj,
        name: *const ::std::os::raw::c_char,
        size: size_t,
        mem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapobj_init_array_private(
        hobj: *mut heapobj,
        name: *const ::std::os::raw::c_char,
        size: size_t,
        elems: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_free(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_void;
}
extern "C" {
    pub fn __real_free(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_void;
}
extern "C" {
    pub fn __wrap_free(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_void;
}
extern "C" {
    pub fn __cobalt_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __real_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __wrap_malloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: size_t,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(
        arg1: *mut _IO_FILE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __s: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __cobalt_vfprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_vfprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_vfprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt___vfprintf_chk(
        stream: *mut FILE,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real___vfprintf_chk(
        stream: *mut FILE,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap___vfprintf_chk(
        stream: *mut FILE,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt___vprintf_chk(
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real___vprintf_chk(
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap___vprintf_chk(
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt___printf_chk(
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real___printf_chk(
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap___printf_chk(
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt___fprintf_chk(
        fp: *mut FILE,
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real___fprintf_chk(
        fp: *mut FILE,
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap___fprintf_chk(
        fp: *mut FILE,
        flag: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __rt_vfprintf_chk(
        stream: *mut FILE,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __rt_vsyslog_chk(
        priority: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn __cobalt_vprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_vprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_vprintf(
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_fprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_fprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_fprintf(
        stream: *mut FILE,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_puts(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_puts(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_puts(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_fputs(
        s: *const ::std::os::raw::c_char,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_fputs(
        s: *const ::std::os::raw::c_char,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_fputs(
        s: *const ::std::os::raw::c_char,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_putchar(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_putchar(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_putchar(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_fputc(c: ::std::os::raw::c_int, stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_fputc(c: ::std::os::raw::c_int, stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_fputc(c: ::std::os::raw::c_int, stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_fwrite(
        ptr: *const ::std::os::raw::c_void,
        sz: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __real_fwrite(
        ptr: *const ::std::os::raw::c_void,
        sz: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __wrap_fwrite(
        ptr: *const ::std::os::raw::c_void,
        sz: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __cobalt_fclose(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_fclose(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_fclose(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_vfprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_vprintf(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_fprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_puts(s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_fputs(s: *const ::std::os::raw::c_char, stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_fputc(c: ::std::os::raw::c_int, stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_putchar(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_fwrite(
        ptr: *const ::std::os::raw::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn rt_syslog(priority: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn rt_vsyslog(
        priority: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn rt_print_init(
        buffer_size: size_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_print_buffer_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rt_print_flush_buffers();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct avlh {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub link: [avlh__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union avlh__bindgen_ty_1 {
    pub offset: isize,
    pub ptr: *mut avlh,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_avlh__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<avlh__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(avlh__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<avlh__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(avlh__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avlh__bindgen_ty_1>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avlh__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avlh__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avlh__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_avlh() {
    assert_eq!(
        ::std::mem::size_of::<avlh>(),
        32usize,
        concat!("Size of: ", stringify!(avlh))
    );
    assert_eq!(
        ::std::mem::align_of::<avlh>(),
        8usize,
        concat!("Alignment of ", stringify!(avlh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avlh>())).link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avlh),
            "::",
            stringify!(link)
        )
    );
}
impl avlh {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn balance(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_balance(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_int,
        balance: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 28u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let balance: u32 = unsafe { ::std::mem::transmute(balance) };
            balance as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type avlh_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const avlh, arg2: *const avlh) -> ::std::os::raw::c_int,
>;
pub type avl_search_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const avl,
        arg2: *const avlh,
        arg3: *mut ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut avlh,
>;
pub type avlh_prn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const avlh,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct avl_searchops {
    pub search: avl_search_t,
    pub cmp: avlh_cmp_t,
}
#[test]
fn bindgen_test_layout_avl_searchops() {
    assert_eq!(
        ::std::mem::size_of::<avl_searchops>(),
        16usize,
        concat!("Size of: ", stringify!(avl_searchops))
    );
    assert_eq!(
        ::std::mem::align_of::<avl_searchops>(),
        8usize,
        concat!("Alignment of ", stringify!(avl_searchops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl_searchops>())).search as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avl_searchops),
            "::",
            stringify!(search)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl_searchops>())).cmp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(avl_searchops),
            "::",
            stringify!(cmp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct avl {
    pub anchor: avlh,
    pub end: [avl__bindgen_ty_1; 3usize],
    pub count: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union avl__bindgen_ty_1 {
    pub offset: isize,
    pub ptr: *mut avlh,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_avl__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<avl__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(avl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<avl__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(avl__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl__bindgen_ty_1>())).offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avl__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl__bindgen_ty_1>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avl__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_avl() {
    assert_eq!(
        ::std::mem::size_of::<avl>(),
        64usize,
        concat!("Size of: ", stringify!(avl))
    );
    assert_eq!(
        ::std::mem::align_of::<avl>(),
        8usize,
        concat!("Alignment of ", stringify!(avl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl>())).anchor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(avl),
            "::",
            stringify!(anchor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl>())).end as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(avl), "::", stringify!(end))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl>())).count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(avl),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<avl>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(avl),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    pub fn avl_inorder(avl: *const avl, holder: *mut avlh, dir: ::std::os::raw::c_int)
        -> *mut avlh;
}
extern "C" {
    pub fn avl_postorder(
        avl: *const avl,
        holder: *mut avlh,
        dir: ::std::os::raw::c_int,
    ) -> *mut avlh;
}
extern "C" {
    pub fn avl_preorder(
        avl: *const avl,
        holder: *mut avlh,
        dir: ::std::os::raw::c_int,
    ) -> *mut avlh;
}
extern "C" {
    pub fn avl_init(avl: *mut avl);
}
extern "C" {
    pub fn avl_destroy(avl: *mut avl);
}
extern "C" {
    pub fn avl_insert(
        avl: *mut avl,
        holder: *mut avlh,
        ops: *const avl_searchops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_insert_front(
        avl: *mut avl,
        holder: *mut avlh,
        ops: *const avl_searchops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_insert_back(
        avl: *mut avl,
        holder: *mut avlh,
        ops: *const avl_searchops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_insert_at(
        avl: *mut avl,
        parent: *mut avlh,
        dir: ::std::os::raw::c_int,
        child: *mut avlh,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_prepend(
        avl: *mut avl,
        holder: *mut avlh,
        ops: *const avl_searchops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_append(
        avl: *mut avl,
        holder: *mut avlh,
        ops: *const avl_searchops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_delete(avl: *mut avl, node: *mut avlh) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_replace(
        avl: *mut avl,
        oldh: *mut avlh,
        newh: *mut avlh,
        ops: *const avl_searchops,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_update(avl: *mut avl, holder: *mut avlh, ops: *const avl_searchops) -> *mut avlh;
}
extern "C" {
    pub fn avl_set(avl: *mut avl, holder: *mut avlh, ops: *const avl_searchops) -> *mut avlh;
}
extern "C" {
    pub fn avl_clear(
        avl: *mut avl,
        destruct: ::std::option::Option<unsafe extern "C" fn(arg1: *mut avlh)>,
    );
}
extern "C" {
    pub fn avl_check(avl: *const avl, ops: *const avl_searchops) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn avl_dump(
        file: *mut FILE,
        avl: *const avl,
        prn: avlh_prn_t,
        indent: ::std::os::raw::c_uint,
        len: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct heapmem_pgentry {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub __bindgen_anon_1: heapmem_pgentry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union heapmem_pgentry__bindgen_ty_1 {
    pub map: u32,
    pub bsize: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_heapmem_pgentry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<heapmem_pgentry__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(heapmem_pgentry__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<heapmem_pgentry__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(heapmem_pgentry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<heapmem_pgentry__bindgen_ty_1>())).map as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_pgentry__bindgen_ty_1),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<heapmem_pgentry__bindgen_ty_1>())).bsize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_pgentry__bindgen_ty_1),
            "::",
            stringify!(bsize)
        )
    );
}
#[test]
fn bindgen_test_layout_heapmem_pgentry() {
    assert_eq!(
        ::std::mem::size_of::<heapmem_pgentry>(),
        12usize,
        concat!("Size of: ", stringify!(heapmem_pgentry))
    );
    assert_eq!(
        ::std::mem::align_of::<heapmem_pgentry>(),
        4usize,
        concat!("Alignment of ", stringify!(heapmem_pgentry))
    );
}
impl heapmem_pgentry {
    #[inline]
    pub fn prev(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_prev(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn next(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_next(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prev: ::std::os::raw::c_uint,
        next: ::std::os::raw::c_uint,
        type_: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let prev: u32 = unsafe { ::std::mem::transmute(prev) };
            prev as u64
        });
        __bindgen_bitfield_unit.set(32usize, 23u8, {
            let next: u32 = unsafe { ::std::mem::transmute(next) };
            next as u64
        });
        __bindgen_bitfield_unit.set(55usize, 6u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct heapmem_range {
    pub addr_node: avlh,
    pub size_node: avlh,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_heapmem_range() {
    assert_eq!(
        ::std::mem::size_of::<heapmem_range>(),
        72usize,
        concat!("Size of: ", stringify!(heapmem_range))
    );
    assert_eq!(
        ::std::mem::align_of::<heapmem_range>(),
        8usize,
        concat!("Alignment of ", stringify!(heapmem_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_range>())).addr_node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_range),
            "::",
            stringify!(addr_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_range>())).size_node as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_range),
            "::",
            stringify!(size_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_range>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_range),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
pub struct heapmem_extent {
    pub next: pvholder,
    pub membase: *mut ::std::os::raw::c_void,
    pub memlim: *mut ::std::os::raw::c_void,
    pub addr_tree: avl,
    pub size_tree: avl,
    pub pagemap: __IncompleteArrayField<heapmem_pgentry>,
}
#[test]
fn bindgen_test_layout_heapmem_extent() {
    assert_eq!(
        ::std::mem::size_of::<heapmem_extent>(),
        160usize,
        concat!("Size of: ", stringify!(heapmem_extent))
    );
    assert_eq!(
        ::std::mem::align_of::<heapmem_extent>(),
        8usize,
        concat!("Alignment of ", stringify!(heapmem_extent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_extent>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_extent),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_extent>())).membase as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_extent),
            "::",
            stringify!(membase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_extent>())).memlim as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_extent),
            "::",
            stringify!(memlim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_extent>())).addr_tree as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_extent),
            "::",
            stringify!(addr_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_extent>())).size_tree as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_extent),
            "::",
            stringify!(size_tree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heapmem_extent>())).pagemap as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(heapmem_extent),
            "::",
            stringify!(pagemap)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct heap_memory {
    pub lock: pthread_mutex_t,
    pub extents: pvlistobj,
    pub arena_size: size_t,
    pub usable_size: size_t,
    pub used_size: size_t,
    pub buckets: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_heap_memory() {
    assert_eq!(
        ::std::mem::size_of::<heap_memory>(),
        104usize,
        concat!("Size of: ", stringify!(heap_memory))
    );
    assert_eq!(
        ::std::mem::align_of::<heap_memory>(),
        8usize,
        concat!("Alignment of ", stringify!(heap_memory))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heap_memory>())).lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_memory),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heap_memory>())).extents as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_memory),
            "::",
            stringify!(extents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heap_memory>())).arena_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_memory),
            "::",
            stringify!(arena_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heap_memory>())).usable_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_memory),
            "::",
            stringify!(usable_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heap_memory>())).used_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_memory),
            "::",
            stringify!(used_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<heap_memory>())).buckets as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(heap_memory),
            "::",
            stringify!(buckets)
        )
    );
}
extern "C" {
    pub fn heapmem_init(
        heap: *mut heap_memory,
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapmem_extend(
        heap: *mut heap_memory,
        mem: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapmem_destroy(heap: *mut heap_memory);
}
extern "C" {
    pub fn heapmem_alloc(heap: *mut heap_memory, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn heapmem_free(
        heap: *mut heap_memory,
        block: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapmem_check(heap: *mut heap_memory, block: *mut ::std::os::raw::c_void) -> ssize_t;
}
extern "C" {
    pub static mut heapmem_main: heap_memory;
}
extern "C" {
    pub static mut __main_catalog: *mut hash_table;
}
extern "C" {
    pub static mut __main_sysgroup: *mut sysgroup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysgroup_memspec {
    #[doc = " next member in sysgroup list."]
    pub next: holder,
}
#[test]
fn bindgen_test_layout_sysgroup_memspec() {
    assert_eq!(
        ::std::mem::size_of::<sysgroup_memspec>(),
        16usize,
        concat!("Size of: ", stringify!(sysgroup_memspec))
    );
    assert_eq!(
        ::std::mem::align_of::<sysgroup_memspec>(),
        8usize,
        concat!("Alignment of ", stringify!(sysgroup_memspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sysgroup_memspec>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysgroup_memspec),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn heapobj_pkg_init_shared() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapobj_init(
        hobj: *mut heapobj,
        name: *const ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapobj_init_array(
        hobj: *mut heapobj,
        name: *const ::std::os::raw::c_char,
        size: size_t,
        elems: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapobj_destroy(hobj: *mut heapobj);
}
extern "C" {
    pub fn heapobj_extend(
        hobj: *mut heapobj,
        size: size_t,
        mem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapobj_alloc(hobj: *mut heapobj, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn heapobj_free(hobj: *mut heapobj, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn heapobj_validate(hobj: *mut heapobj, ptr: *mut ::std::os::raw::c_void) -> size_t;
}
extern "C" {
    pub fn heapobj_inquire(hobj: *mut heapobj) -> size_t;
}
extern "C" {
    pub fn heapobj_get_size(hobj: *mut heapobj) -> size_t;
}
extern "C" {
    pub fn heapobj_bind_session(session: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapobj_unbind_session();
}
extern "C" {
    pub fn heapobj_unlink_session(session: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xnmalloc(size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn xnfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn xnstrdup(ptr: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct threadobj_corespec {
    pub handle: xnhandle_t,
    pub __bindgen_anon_1: threadobj_corespec__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union threadobj_corespec__bindgen_ty_1 {
    pub u_winoff: __u32,
    pub u_window: *mut xnthread_user_window,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_threadobj_corespec__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<threadobj_corespec__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(threadobj_corespec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<threadobj_corespec__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(threadobj_corespec__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadobj_corespec__bindgen_ty_1>())).u_winoff as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_corespec__bindgen_ty_1),
            "::",
            stringify!(u_winoff)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadobj_corespec__bindgen_ty_1>())).u_window as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_corespec__bindgen_ty_1),
            "::",
            stringify!(u_window)
        )
    );
}
#[test]
fn bindgen_test_layout_threadobj_corespec() {
    assert_eq!(
        ::std::mem::size_of::<threadobj_corespec>(),
        16usize,
        concat!("Size of: ", stringify!(threadobj_corespec))
    );
    assert_eq!(
        ::std::mem::align_of::<threadobj_corespec>(),
        8usize,
        concat!("Alignment of ", stringify!(threadobj_corespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_corespec>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_corespec),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadobj_stat {
    #[doc = " Execution time in primary mode (ns)."]
    pub xtime: ticks_t,
    #[doc = " Current timeout value (ns)."]
    pub timeout: ticks_t,
    #[doc = " Number of primary->secondary mode switches."]
    pub msw: u64,
    #[doc = " Number of context switches."]
    pub csw: u64,
    #[doc = " Number of Xenomai syscalls."]
    pub xsc: u64,
    #[doc = " Current CPU for thread."]
    pub cpu: ::std::os::raw::c_int,
    #[doc = " Scheduler lock nesting count."]
    pub schedlock: ::std::os::raw::c_int,
    #[doc = " Cobalt thread status bits."]
    pub status: ::std::os::raw::c_uint,
    #[doc = " Number of page faults."]
    pub pf: u32,
}
#[test]
fn bindgen_test_layout_threadobj_stat() {
    assert_eq!(
        ::std::mem::size_of::<threadobj_stat>(),
        56usize,
        concat!("Size of: ", stringify!(threadobj_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<threadobj_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(threadobj_stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).xtime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(xtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).timeout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).msw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(msw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).csw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(csw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).xsc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(xsc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).cpu as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).schedlock as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(schedlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).status as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_stat>())).pf as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_stat),
            "::",
            stringify!(pf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct traceobj {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct threadobj {
    pub magic: ::std::os::raw::c_uint,
    pub ptid: pthread_t,
    pub lock: pthread_mutex_t,
    pub schedlock_depth: ::std::os::raw::c_int,
    pub cancel_state: ::std::os::raw::c_int,
    pub status: ::std::os::raw::c_int,
    pub run_state: ::std::os::raw::c_int,
    pub policy: ::std::os::raw::c_int,
    pub schedparam: sched_param_ex,
    pub global_priority: ::std::os::raw::c_int,
    pub cnode: pid_t,
    pub pid: pid_t,
    pub name: [::std::os::raw::c_char; 32usize],
    pub finalizer: ::std::option::Option<unsafe extern "C" fn(thobj: *mut threadobj)>,
    pub core_offset: ::std::os::raw::c_int,
    pub errno_pointer: *mut ::std::os::raw::c_int,
    pub wait_sobj: *mut syncobj,
    pub wait_link: holder,
    pub wait_status: ::std::os::raw::c_int,
    pub wait_prio: ::std::os::raw::c_int,
    pub wait_union: memoff_t,
    pub wait_size: size_t,
    pub periodic_timer: timer_t,
    pub core: threadobj_corespec,
    pub tslice: timespec,
    pub barrier: pthread_cond_t,
    pub tracer: *mut traceobj,
    pub cancel_sem: *mut sem_t,
    pub memspec: sysgroup_memspec,
    pub btd: backtrace_data,
}
#[test]
fn bindgen_test_layout_threadobj() {
    assert_eq!(
        ::std::mem::size_of::<threadobj>(),
        376usize,
        concat!("Size of: ", stringify!(threadobj))
    );
    assert_eq!(
        ::std::mem::align_of::<threadobj>(),
        8usize,
        concat!("Alignment of ", stringify!(threadobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).ptid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(ptid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).schedlock_depth as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(schedlock_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).cancel_state as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(cancel_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).status as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).run_state as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(run_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).policy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).schedparam as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).global_priority as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(global_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).cnode as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).pid as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).name as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).finalizer as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(finalizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).core_offset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(core_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).errno_pointer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(errno_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).wait_sobj as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(wait_sobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).wait_link as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(wait_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).wait_status as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(wait_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).wait_prio as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(wait_prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).wait_union as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(wait_union)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).wait_size as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(wait_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).periodic_timer as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(periodic_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).core as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(core)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).tslice as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(tslice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).barrier as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(barrier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).tracer as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(tracer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).cancel_sem as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(cancel_sem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).memspec as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(memspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj>())).btd as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj),
            "::",
            stringify!(btd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct threadobj_init_data {
    pub magic: ::std::os::raw::c_uint,
    pub affinity: cpu_set_t,
    pub policy: ::std::os::raw::c_int,
    pub param_ex: sched_param_ex,
    pub finalizer: ::std::option::Option<unsafe extern "C" fn(thobj: *mut threadobj)>,
}
#[test]
fn bindgen_test_layout_threadobj_init_data() {
    assert_eq!(
        ::std::mem::size_of::<threadobj_init_data>(),
        208usize,
        concat!("Size of: ", stringify!(threadobj_init_data))
    );
    assert_eq!(
        ::std::mem::align_of::<threadobj_init_data>(),
        8usize,
        concat!("Alignment of ", stringify!(threadobj_init_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_init_data>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_init_data),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_init_data>())).affinity as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_init_data),
            "::",
            stringify!(affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_init_data>())).policy as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_init_data),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_init_data>())).param_ex as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_init_data),
            "::",
            stringify!(param_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadobj_init_data>())).finalizer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(threadobj_init_data),
            "::",
            stringify!(finalizer)
        )
    );
}
extern "C" {
    pub static mut threadobj_high_prio: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut threadobj_irq_prio: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut threadobj_tskey: pthread_key_t;
}
extern "C" {
    pub fn __threadobj_alloc(
        tcb_struct_size: size_t,
        wait_union_size: size_t,
        thobj_offset: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn threadobj_init(
        thobj: *mut threadobj,
        idata: *mut threadobj_init_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_start(thobj: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_shadow(
        thobj: *mut threadobj,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_prologue(
        thobj: *mut threadobj,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_wait_start();
}
extern "C" {
    pub fn threadobj_notify_entry();
}
extern "C" {
    pub fn threadobj_cancel(thobj: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_uninit(thobj: *mut threadobj);
}
extern "C" {
    pub fn threadobj_suspend(thobj: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_resume(thobj: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_unblock(thobj: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __threadobj_lock_sched(current: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_lock_sched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __threadobj_unlock_sched(current: *mut threadobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_unlock_sched() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_set_schedparam(
        thobj: *mut threadobj,
        policy: ::std::os::raw::c_int,
        param_ex: *const sched_param_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_set_schedprio(
        thobj: *mut threadobj,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_set_mode(
        clrmask: ::std::os::raw::c_int,
        setmask: ::std::os::raw::c_int,
        mode_r: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_set_periodic(
        thobj: *mut threadobj,
        idate: *const timespec,
        period: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_wait_period(overruns_r: *mut ::std::os::raw::c_ulong)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_spin(ns: ticks_t);
}
extern "C" {
    pub fn threadobj_stat(
        thobj: *mut threadobj,
        stat: *mut threadobj_stat,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_sleep(ts: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn threadobj_set_current_name(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn threadobj_init_key();
}
extern "C" {
    pub fn threadobj_pkg_init(anon_session: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        32usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_whence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_whence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<flock>())).l_pid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(flock),
            "::",
            stringify!(l_pid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn fcntl(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
        __advise: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(
        __fd: ::std::os::raw::c_int,
        __offset: off_t,
        __len: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_open(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_open(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_open(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_open64(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_open64(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_open64(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt___open_2(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real___open_2(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap___open_2(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt___open64_2(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real___open64_2(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap___open64_2(
        path: *const ::std::os::raw::c_char,
        oflag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __cobalt_fcntl(
        fd: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __real_fcntl(
        fd: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wrap_fcntl(
        fd: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hashobj {
    pub key: memoff_t,
    pub static_key: [::std::os::raw::c_char; 16usize],
    pub len: size_t,
    pub link: holder,
}
#[test]
fn bindgen_test_layout_hashobj() {
    assert_eq!(
        ::std::mem::size_of::<hashobj>(),
        48usize,
        concat!("Size of: ", stringify!(hashobj))
    );
    assert_eq!(
        ::std::mem::align_of::<hashobj>(),
        8usize,
        concat!("Alignment of ", stringify!(hashobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashobj>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashobj),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashobj>())).static_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hashobj),
            "::",
            stringify!(static_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashobj>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hashobj),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hashobj>())).link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hashobj),
            "::",
            stringify!(link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_bucket {
    pub obj_list: listobj,
}
#[test]
fn bindgen_test_layout_hash_bucket() {
    assert_eq!(
        ::std::mem::size_of::<hash_bucket>(),
        16usize,
        concat!("Size of: ", stringify!(hash_bucket))
    );
    assert_eq!(
        ::std::mem::align_of::<hash_bucket>(),
        8usize,
        concat!("Alignment of ", stringify!(hash_bucket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_bucket>())).obj_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_bucket),
            "::",
            stringify!(obj_list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hash_table {
    pub table: [hash_bucket; 256usize],
    pub lock: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_hash_table() {
    assert_eq!(
        ::std::mem::size_of::<hash_table>(),
        4136usize,
        concat!("Size of: ", stringify!(hash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<hash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(hash_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_table>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_table>())).lock as *const _ as usize },
        4096usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_table),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hash_operations {
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(
            l: *const ::std::os::raw::c_void,
            r: *const ::std::os::raw::c_void,
            len: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub probe:
        ::std::option::Option<unsafe extern "C" fn(oldobj: *mut hashobj) -> ::std::os::raw::c_int>,
    pub alloc:
        ::std::option::Option<unsafe extern "C" fn(len: size_t) -> *mut ::std::os::raw::c_void>,
    pub free: ::std::option::Option<unsafe extern "C" fn(key: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_hash_operations() {
    assert_eq!(
        ::std::mem::size_of::<hash_operations>(),
        32usize,
        concat!("Size of: ", stringify!(hash_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<hash_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(hash_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_operations>())).compare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_operations),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_operations>())).probe as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_operations),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_operations>())).alloc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_operations),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hash_operations>())).free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hash_operations),
            "::",
            stringify!(free)
        )
    );
}
pub type hash_walk_op = ::std::option::Option<
    unsafe extern "C" fn(
        t: *mut hash_table,
        obj: *mut hashobj,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvhashobj {
    pub key: *const ::std::os::raw::c_void,
    pub len: size_t,
    pub link: pvholder,
}
#[test]
fn bindgen_test_layout_pvhashobj() {
    assert_eq!(
        ::std::mem::size_of::<pvhashobj>(),
        32usize,
        concat!("Size of: ", stringify!(pvhashobj))
    );
    assert_eq!(
        ::std::mem::align_of::<pvhashobj>(),
        8usize,
        concat!("Alignment of ", stringify!(pvhashobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhashobj>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhashobj),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhashobj>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhashobj),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhashobj>())).link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhashobj),
            "::",
            stringify!(link)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvhash_bucket {
    pub obj_list: pvlistobj,
}
#[test]
fn bindgen_test_layout_pvhash_bucket() {
    assert_eq!(
        ::std::mem::size_of::<pvhash_bucket>(),
        16usize,
        concat!("Size of: ", stringify!(pvhash_bucket))
    );
    assert_eq!(
        ::std::mem::align_of::<pvhash_bucket>(),
        8usize,
        concat!("Alignment of ", stringify!(pvhash_bucket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhash_bucket>())).obj_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhash_bucket),
            "::",
            stringify!(obj_list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvhash_table {
    pub table: [pvhash_bucket; 256usize],
    pub lock: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pvhash_table() {
    assert_eq!(
        ::std::mem::size_of::<pvhash_table>(),
        4136usize,
        concat!("Size of: ", stringify!(pvhash_table))
    );
    assert_eq!(
        ::std::mem::align_of::<pvhash_table>(),
        8usize,
        concat!("Alignment of ", stringify!(pvhash_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhash_table>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhash_table),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhash_table>())).lock as *const _ as usize },
        4096usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhash_table),
            "::",
            stringify!(lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvhash_operations {
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(
            l: *const ::std::os::raw::c_void,
            r: *const ::std::os::raw::c_void,
            len: size_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_pvhash_operations() {
    assert_eq!(
        ::std::mem::size_of::<pvhash_operations>(),
        8usize,
        concat!("Size of: ", stringify!(pvhash_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<pvhash_operations>(),
        8usize,
        concat!("Alignment of ", stringify!(pvhash_operations))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvhash_operations>())).compare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvhash_operations),
            "::",
            stringify!(compare)
        )
    );
}
pub type pvhash_walk_op = ::std::option::Option<
    unsafe extern "C" fn(
        t: *mut pvhash_table,
        obj: *mut pvhashobj,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __hash_key(
        key: *const ::std::os::raw::c_void,
        length: size_t,
        c: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __hash_init(heap: *mut ::std::os::raw::c_void, t: *mut hash_table);
}
extern "C" {
    pub fn __hash_enter(
        t: *mut hash_table,
        key: *const ::std::os::raw::c_void,
        len: size_t,
        newobj: *mut hashobj,
        hops: *const hash_operations,
        nodup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_destroy(t: *mut hash_table);
}
extern "C" {
    pub fn hash_remove(
        t: *mut hash_table,
        delobj: *mut hashobj,
        hops: *const hash_operations,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_search(
        t: *mut hash_table,
        key: *const ::std::os::raw::c_void,
        len: size_t,
        hops: *const hash_operations,
    ) -> *mut hashobj;
}
extern "C" {
    pub fn hash_walk(
        t: *mut hash_table,
        walk: hash_walk_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __hash_enter_probe(
        t: *mut hash_table,
        key: *const ::std::os::raw::c_void,
        len: size_t,
        newobj: *mut hashobj,
        hops: *const hash_operations,
        nodup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __pvhash_enter(
        t: *mut pvhash_table,
        key: *const ::std::os::raw::c_void,
        len: size_t,
        newobj: *mut pvhashobj,
        hops: *const pvhash_operations,
        nodup: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hash_search_probe(
        t: *mut hash_table,
        key: *const ::std::os::raw::c_void,
        len: size_t,
        hops: *const hash_operations,
    ) -> *mut hashobj;
}
extern "C" {
    pub fn pvhash_init(t: *mut pvhash_table);
}
extern "C" {
    pub fn pvhash_remove(
        t: *mut pvhash_table,
        delobj: *mut pvhashobj,
        hops: *const pvhash_operations,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvhash_search(
        t: *mut pvhash_table,
        key: *const ::std::os::raw::c_void,
        len: size_t,
        hops: *const pvhash_operations,
    ) -> *mut pvhashobj;
}
extern "C" {
    pub fn pvhash_walk(
        t: *mut pvhash_table,
        walk: pvhash_walk_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _obstack_chunk {
    pub limit: *mut ::std::os::raw::c_char,
    pub prev: *mut _obstack_chunk,
    pub contents: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout__obstack_chunk() {
    assert_eq!(
        ::std::mem::size_of::<_obstack_chunk>(),
        24usize,
        concat!("Size of: ", stringify!(_obstack_chunk))
    );
    assert_eq!(
        ::std::mem::align_of::<_obstack_chunk>(),
        8usize,
        concat!("Alignment of ", stringify!(_obstack_chunk))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_obstack_chunk>())).limit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_obstack_chunk),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_obstack_chunk>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_obstack_chunk),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_obstack_chunk>())).contents as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_obstack_chunk),
            "::",
            stringify!(contents)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obstack {
    pub chunk_size: ::std::os::raw::c_long,
    pub chunk: *mut _obstack_chunk,
    pub object_base: *mut ::std::os::raw::c_char,
    pub next_free: *mut ::std::os::raw::c_char,
    pub chunk_limit: *mut ::std::os::raw::c_char,
    pub temp: obstack__bindgen_ty_1,
    pub alignment_mask: ::std::os::raw::c_int,
    pub chunkfun: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_long,
        ) -> *mut _obstack_chunk,
    >,
    pub freefun: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut _obstack_chunk),
    >,
    pub extra_arg: *mut ::std::os::raw::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union obstack__bindgen_ty_1 {
    pub tempint: ::std::os::raw::c_long,
    pub tempptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_obstack__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<obstack__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(obstack__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<obstack__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(obstack__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack__bindgen_ty_1>())).tempint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack__bindgen_ty_1),
            "::",
            stringify!(tempint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack__bindgen_ty_1>())).tempptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack__bindgen_ty_1),
            "::",
            stringify!(tempptr)
        )
    );
}
#[test]
fn bindgen_test_layout_obstack() {
    assert_eq!(
        ::std::mem::size_of::<obstack>(),
        88usize,
        concat!("Size of: ", stringify!(obstack))
    );
    assert_eq!(
        ::std::mem::align_of::<obstack>(),
        8usize,
        concat!("Alignment of ", stringify!(obstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).chunk_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(chunk_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).chunk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).object_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(object_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).next_free as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(next_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).chunk_limit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(chunk_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).temp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(temp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).alignment_mask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(alignment_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).chunkfun as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(chunkfun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).freefun as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(freefun)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<obstack>())).extra_arg as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(obstack),
            "::",
            stringify!(extra_arg)
        )
    );
}
impl obstack {
    #[inline]
    pub fn use_extra_arg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_extra_arg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn maybe_empty_object(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_maybe_empty_object(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alloc_failed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alloc_failed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_extra_arg: ::std::os::raw::c_uint,
        maybe_empty_object: ::std::os::raw::c_uint,
        alloc_failed: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_extra_arg: u32 = unsafe { ::std::mem::transmute(use_extra_arg) };
            use_extra_arg as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let maybe_empty_object: u32 = unsafe { ::std::mem::transmute(maybe_empty_object) };
            maybe_empty_object as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let alloc_failed: u32 = unsafe { ::std::mem::transmute(alloc_failed) };
            alloc_failed as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn _obstack_newchunk(arg1: *mut obstack, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _obstack_begin(
        arg1: *mut obstack,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_void,
        >,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _obstack_begin_1(
        arg1: *mut obstack,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_long,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        arg6: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _obstack_memory_used(arg1: *mut obstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_free(obstack: *mut obstack, block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub static mut obstack_alloc_failed_handler: ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut obstack_exit_failure: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsobj {}
#[test]
fn bindgen_test_layout_fsobj() {
    assert_eq!(
        ::std::mem::size_of::<fsobj>(),
        0usize,
        concat!("Size of: ", stringify!(fsobj))
    );
    assert_eq!(
        ::std::mem::align_of::<fsobj>(),
        1usize,
        concat!("Alignment of ", stringify!(fsobj))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct registry_operations {}
#[test]
fn bindgen_test_layout_registry_operations() {
    assert_eq!(
        ::std::mem::size_of::<registry_operations>(),
        0usize,
        concat!("Size of: ", stringify!(registry_operations))
    );
    assert_eq!(
        ::std::mem::align_of::<registry_operations>(),
        1usize,
        concat!("Alignment of ", stringify!(registry_operations))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clusterobj {
    pub cnode: pid_t,
    pub hobj: hashobj,
}
#[test]
fn bindgen_test_layout_clusterobj() {
    assert_eq!(
        ::std::mem::size_of::<clusterobj>(),
        56usize,
        concat!("Size of: ", stringify!(clusterobj))
    );
    assert_eq!(
        ::std::mem::align_of::<clusterobj>(),
        8usize,
        concat!("Alignment of ", stringify!(clusterobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterobj>())).cnode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterobj),
            "::",
            stringify!(cnode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<clusterobj>())).hobj as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clusterobj),
            "::",
            stringify!(hobj)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dictionary {
    pub table: hash_table,
    pub hobj: hashobj,
}
#[test]
fn bindgen_test_layout_dictionary() {
    assert_eq!(
        ::std::mem::size_of::<dictionary>(),
        4184usize,
        concat!("Size of: ", stringify!(dictionary))
    );
    assert_eq!(
        ::std::mem::align_of::<dictionary>(),
        8usize,
        concat!("Alignment of ", stringify!(dictionary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dictionary>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dictionary),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dictionary>())).hobj as *const _ as usize },
        4136usize,
        concat!(
            "Offset of field: ",
            stringify!(dictionary),
            "::",
            stringify!(hobj)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cluster {
    pub d: *mut dictionary,
}
#[test]
fn bindgen_test_layout_cluster() {
    assert_eq!(
        ::std::mem::size_of::<cluster>(),
        8usize,
        concat!("Size of: ", stringify!(cluster))
    );
    assert_eq!(
        ::std::mem::align_of::<cluster>(),
        8usize,
        concat!("Alignment of ", stringify!(cluster))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cluster>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cluster),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct syndictionary {
    pub table: hash_table,
    pub sobj: syncobj,
    pub hobj: hashobj,
}
#[test]
fn bindgen_test_layout_syndictionary() {
    assert_eq!(
        ::std::mem::size_of::<syndictionary>(),
        4264usize,
        concat!("Size of: ", stringify!(syndictionary))
    );
    assert_eq!(
        ::std::mem::align_of::<syndictionary>(),
        8usize,
        concat!("Alignment of ", stringify!(syndictionary))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syndictionary>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syndictionary),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syndictionary>())).sobj as *const _ as usize },
        4136usize,
        concat!(
            "Offset of field: ",
            stringify!(syndictionary),
            "::",
            stringify!(sobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syndictionary>())).hobj as *const _ as usize },
        4216usize,
        concat!(
            "Offset of field: ",
            stringify!(syndictionary),
            "::",
            stringify!(hobj)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct syncluster {
    pub d: *mut syndictionary,
}
#[test]
fn bindgen_test_layout_syncluster() {
    assert_eq!(
        ::std::mem::size_of::<syncluster>(),
        8usize,
        concat!("Size of: ", stringify!(syncluster))
    );
    assert_eq!(
        ::std::mem::align_of::<syncluster>(),
        8usize,
        concat!("Alignment of ", stringify!(syncluster))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<syncluster>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syncluster),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pvclusterobj {
    pub hobj: pvhashobj,
}
#[test]
fn bindgen_test_layout_pvclusterobj() {
    assert_eq!(
        ::std::mem::size_of::<pvclusterobj>(),
        32usize,
        concat!("Size of: ", stringify!(pvclusterobj))
    );
    assert_eq!(
        ::std::mem::align_of::<pvclusterobj>(),
        8usize,
        concat!("Alignment of ", stringify!(pvclusterobj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvclusterobj>())).hobj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvclusterobj),
            "::",
            stringify!(hobj)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvcluster {
    pub table: pvhash_table,
}
#[test]
fn bindgen_test_layout_pvcluster() {
    assert_eq!(
        ::std::mem::size_of::<pvcluster>(),
        4136usize,
        concat!("Size of: ", stringify!(pvcluster))
    );
    assert_eq!(
        ::std::mem::align_of::<pvcluster>(),
        8usize,
        concat!("Alignment of ", stringify!(pvcluster))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvcluster>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvcluster),
            "::",
            stringify!(table)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pvsyncluster {
    pub c: pvcluster,
    pub sobj: syncobj,
}
#[test]
fn bindgen_test_layout_pvsyncluster() {
    assert_eq!(
        ::std::mem::size_of::<pvsyncluster>(),
        4216usize,
        concat!("Size of: ", stringify!(pvsyncluster))
    );
    assert_eq!(
        ::std::mem::align_of::<pvsyncluster>(),
        8usize,
        concat!("Alignment of ", stringify!(pvsyncluster))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvsyncluster>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pvsyncluster),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pvsyncluster>())).sobj as *const _ as usize },
        4136usize,
        concat!(
            "Offset of field: ",
            stringify!(pvsyncluster),
            "::",
            stringify!(sobj)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct syncluster_wait_struct {
    pub __bindgen_anon_1: syncluster_wait_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union syncluster_wait_struct__bindgen_ty_1 {
    pub name_ref: memoff_t,
    pub name: *const ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_syncluster_wait_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<syncluster_wait_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(syncluster_wait_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<syncluster_wait_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(syncluster_wait_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<syncluster_wait_struct__bindgen_ty_1>())).name_ref as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syncluster_wait_struct__bindgen_ty_1),
            "::",
            stringify!(name_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<syncluster_wait_struct__bindgen_ty_1>())).name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(syncluster_wait_struct__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_syncluster_wait_struct() {
    assert_eq!(
        ::std::mem::size_of::<syncluster_wait_struct>(),
        8usize,
        concat!("Size of: ", stringify!(syncluster_wait_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<syncluster_wait_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(syncluster_wait_struct))
    );
}
extern "C" {
    pub fn pvcluster_init(
        c: *mut pvcluster,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvcluster_destroy(c: *mut pvcluster);
}
extern "C" {
    pub fn pvcluster_addobj(
        c: *mut pvcluster,
        name: *const ::std::os::raw::c_char,
        cobj: *mut pvclusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvcluster_addobj_dup(
        c: *mut pvcluster,
        name: *const ::std::os::raw::c_char,
        cobj: *mut pvclusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvcluster_delobj(c: *mut pvcluster, cobj: *mut pvclusterobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvcluster_findobj(
        c: *mut pvcluster,
        name: *const ::std::os::raw::c_char,
    ) -> *mut pvclusterobj;
}
extern "C" {
    pub fn pvcluster_walk(
        c: *mut pvcluster,
        walk: ::std::option::Option<
            unsafe extern "C" fn(
                c: *mut pvcluster,
                cobj: *mut pvclusterobj,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvsyncluster_init(
        sc: *mut pvsyncluster,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvsyncluster_destroy(sc: *mut pvsyncluster);
}
extern "C" {
    pub fn pvsyncluster_addobj(
        sc: *mut pvsyncluster,
        name: *const ::std::os::raw::c_char,
        cobj: *mut pvclusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvsyncluster_delobj(
        sc: *mut pvsyncluster,
        cobj: *mut pvclusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pvsyncluster_findobj(
        sc: *mut pvsyncluster,
        name: *const ::std::os::raw::c_char,
        timeout: *const timespec,
        cobjp: *mut *mut pvclusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cluster_init(
        c: *mut cluster,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cluster_addobj(
        c: *mut cluster,
        name: *const ::std::os::raw::c_char,
        cobj: *mut clusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cluster_addobj_dup(
        c: *mut cluster,
        name: *const ::std::os::raw::c_char,
        cobj: *mut clusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cluster_delobj(c: *mut cluster, cobj: *mut clusterobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cluster_findobj(c: *mut cluster, name: *const ::std::os::raw::c_char)
        -> *mut clusterobj;
}
extern "C" {
    pub fn cluster_walk(
        c: *mut cluster,
        walk: ::std::option::Option<
            unsafe extern "C" fn(c: *mut cluster, cobj: *mut clusterobj) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncluster_init(
        sc: *mut syncluster,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncluster_addobj(
        sc: *mut syncluster,
        name: *const ::std::os::raw::c_char,
        cobj: *mut clusterobj,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncluster_delobj(sc: *mut syncluster, cobj: *mut clusterobj) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syncluster_findobj(
        sc: *mut syncluster,
        name: *const ::std::os::raw::c_char,
        timeout: *const timespec,
        cobjp: *mut *mut clusterobj,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @addtogroup alchemy_timer"]
#[doc = " @{"]
pub type RTIME = ticks_t;
pub type SRTIME = sticks_t;
#[doc = " @brief Timer status descriptor"]
#[doc = " @anchor RT_TIMER_INFO"]
#[doc = ""]
#[doc = " This structure reports information about the Alchemy clock,"]
#[doc = " returned by a call to rt_timer_inquire()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_timer_info {
    #[doc = " Clock resolution in nanoseconds."]
    pub period: RTIME,
    #[doc = " Current monotonic date expressed in clock ticks. The"]
    #[doc = " duration of a tick depends on the Alchemy clock resolution"]
    #[doc = " for the process (see --alchemy-clock-resolution option,"]
    #[doc = " defaults to 1 nanosecond)."]
    pub date: RTIME,
}
#[test]
fn bindgen_test_layout_rt_timer_info() {
    assert_eq!(
        ::std::mem::size_of::<rt_timer_info>(),
        16usize,
        concat!("Size of: ", stringify!(rt_timer_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rt_timer_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_timer_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rt_timer_info>())).period as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer_info),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rt_timer_info>())).date as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer_info),
            "::",
            stringify!(date)
        )
    );
}
pub type RT_TIMER_INFO = rt_timer_info;
extern "C" {
    pub static mut alchemy_clock: clockobj;
}
extern "C" {
    pub fn rt_timer_ns2ticks(ns: SRTIME) -> SRTIME;
}
extern "C" {
    pub fn rt_timer_ticks2ns(ticks: SRTIME) -> SRTIME;
}
extern "C" {
    pub fn rt_timer_inquire(info: *mut RT_TIMER_INFO);
}
extern "C" {
    pub fn rt_timer_spin(ns: RTIME);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RT_TASK {
    pub handle: usize,
    pub thread: pthread_t,
}
#[test]
fn bindgen_test_layout_RT_TASK() {
    assert_eq!(
        ::std::mem::size_of::<RT_TASK>(),
        16usize,
        concat!("Size of: ", stringify!(RT_TASK))
    );
    assert_eq!(
        ::std::mem::align_of::<RT_TASK>(),
        8usize,
        concat!("Alignment of ", stringify!(RT_TASK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK>())).thread as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK),
            "::",
            stringify!(thread)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RT_TASK_MCB {
    pub flowid: ::std::os::raw::c_int,
    pub opcode: ::std::os::raw::c_int,
    pub __bindgen_anon_1: RT_TASK_MCB__bindgen_ty_1,
    pub size: ssize_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RT_TASK_MCB__bindgen_ty_1 {
    pub __dref: memoff_t,
    pub data: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_RT_TASK_MCB__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RT_TASK_MCB__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RT_TASK_MCB__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RT_TASK_MCB__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(RT_TASK_MCB__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<RT_TASK_MCB__bindgen_ty_1>())).__dref as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_MCB__bindgen_ty_1),
            "::",
            stringify!(__dref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_MCB__bindgen_ty_1>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_MCB__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
}
#[test]
fn bindgen_test_layout_RT_TASK_MCB() {
    assert_eq!(
        ::std::mem::size_of::<RT_TASK_MCB>(),
        24usize,
        concat!("Size of: ", stringify!(RT_TASK_MCB))
    );
    assert_eq!(
        ::std::mem::align_of::<RT_TASK_MCB>(),
        8usize,
        concat!("Alignment of ", stringify!(RT_TASK_MCB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_MCB>())).flowid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_MCB),
            "::",
            stringify!(flowid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_MCB>())).opcode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_MCB),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_MCB>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_MCB),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " @brief Task status descriptor"]
#[doc = " @anchor RT_TASK_INFO"]
#[doc = ""]
#[doc = " This structure reports various static and runtime information about"]
#[doc = " a real-time task, returned by a call to rt_task_inquire()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RT_TASK_INFO {
    #[doc = " Task priority."]
    pub prio: ::std::os::raw::c_int,
    #[doc = " Task status."]
    pub stat: threadobj_stat,
    #[doc = " Name of task."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = " Host pid."]
    pub pid: pid_t,
}
#[test]
fn bindgen_test_layout_RT_TASK_INFO() {
    assert_eq!(
        ::std::mem::size_of::<RT_TASK_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(RT_TASK_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<RT_TASK_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(RT_TASK_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_INFO>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_INFO),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_INFO>())).stat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_INFO),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_INFO>())).name as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_INFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_TASK_INFO>())).pid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_TASK_INFO),
            "::",
            stringify!(pid)
        )
    );
}
extern "C" {
    pub fn rt_task_create(
        task: *mut RT_TASK,
        name: *const ::std::os::raw::c_char,
        stksize: ::std::os::raw::c_int,
        prio: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __current_rt_task_create(
        task: *mut RT_TASK,
        name: *const ::std::os::raw::c_char,
        stksize: ::std::os::raw::c_int,
        prio: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_delete(task: *mut RT_TASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_set_affinity(
        task: *mut RT_TASK,
        cpus: *const cpu_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_start(
        task: *mut RT_TASK,
        entry: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_spawn(
        task: *mut RT_TASK,
        name: *const ::std::os::raw::c_char,
        stksize: ::std::os::raw::c_int,
        prio: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        entry: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __current_rt_task_spawn(
        task: *mut RT_TASK,
        name: *const ::std::os::raw::c_char,
        stksize: ::std::os::raw::c_int,
        prio: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        entry: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_shadow(
        task: *mut RT_TASK,
        name: *const ::std::os::raw::c_char,
        prio: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_join(task: *mut RT_TASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_set_periodic(
        task: *mut RT_TASK,
        idate: RTIME,
        period: RTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __current_rt_task_set_periodic(
        task: *mut RT_TASK,
        idate: RTIME,
        period: RTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_wait_period(overruns_r: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_sleep(delay: RTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_sleep_until(date: RTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_same(task1: *mut RT_TASK, task2: *mut RT_TASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_suspend(task: *mut RT_TASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_resume(task: *mut RT_TASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_self() -> *mut RT_TASK;
}
extern "C" {
    pub fn rt_task_set_priority(
        task: *mut RT_TASK,
        prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_set_mode(
        clrmask: ::std::os::raw::c_int,
        setmask: ::std::os::raw::c_int,
        mode_r: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_unblock(task: *mut RT_TASK) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_slice(task: *mut RT_TASK, quantum: RTIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_inquire(task: *mut RT_TASK, info: *mut RT_TASK_INFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_send_timed(
        task: *mut RT_TASK,
        mcb_s: *mut RT_TASK_MCB,
        mcb_r: *mut RT_TASK_MCB,
        abs_timeout: *const timespec,
    ) -> ssize_t;
}
extern "C" {
    pub fn rt_task_receive_timed(
        mcb_r: *mut RT_TASK_MCB,
        abs_timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_reply(
        flowid: ::std::os::raw::c_int,
        mcb_s: *mut RT_TASK_MCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_bind(
        task: *mut RT_TASK,
        name: *const ::std::os::raw::c_char,
        timeout: RTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_task_unbind(task: *mut RT_TASK) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alchemy_task {
    pub name: [::std::os::raw::c_char; 32usize],
    pub mode: ::std::os::raw::c_int,
    pub affinity: cpu_set_t,
    pub suspends: ::std::os::raw::c_int,
    pub sobj_msg: syncobj,
    pub flowgen: ::std::os::raw::c_int,
    pub thobj: threadobj,
    pub cobj: clusterobj,
    pub entry: ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
    pub self_: RT_TASK,
    pub fsobj: fsobj,
}
#[test]
fn bindgen_test_layout_alchemy_task() {
    assert_eq!(
        ::std::mem::size_of::<alchemy_task>(),
        728usize,
        concat!("Size of: ", stringify!(alchemy_task))
    );
    assert_eq!(
        ::std::mem::align_of::<alchemy_task>(),
        8usize,
        concat!("Alignment of ", stringify!(alchemy_task))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).mode as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).affinity as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).suspends as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(suspends)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).sobj_msg as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(sobj_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).flowgen as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(flowgen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).thobj as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(thobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).cobj as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(cobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).entry as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).arg as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).self_ as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(self_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task>())).fsobj as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task),
            "::",
            stringify!(fsobj)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alchemy_task_wait {
    pub request: RT_TASK_MCB,
    pub reply: RT_TASK_MCB,
}
#[test]
fn bindgen_test_layout_alchemy_task_wait() {
    assert_eq!(
        ::std::mem::size_of::<alchemy_task_wait>(),
        48usize,
        concat!("Size of: ", stringify!(alchemy_task_wait))
    );
    assert_eq!(
        ::std::mem::align_of::<alchemy_task_wait>(),
        8usize,
        concat!("Alignment of ", stringify!(alchemy_task_wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task_wait>())).request as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task_wait),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_task_wait>())).reply as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_task_wait),
            "::",
            stringify!(reply)
        )
    );
}
extern "C" {
    pub fn get_alchemy_task(
        task: *mut RT_TASK,
        err_r: *mut ::std::os::raw::c_int,
    ) -> *mut alchemy_task;
}
extern "C" {
    pub fn get_alchemy_task_or_self(
        task: *mut RT_TASK,
        err_r: *mut ::std::os::raw::c_int,
    ) -> *mut alchemy_task;
}
extern "C" {
    pub fn put_alchemy_task(tcb: *mut alchemy_task);
}
extern "C" {
    pub static mut alchemy_task_table: syncluster;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RT_QUEUE {
    pub handle: usize,
}
#[test]
fn bindgen_test_layout_RT_QUEUE() {
    assert_eq!(
        ::std::mem::size_of::<RT_QUEUE>(),
        8usize,
        concat!("Size of: ", stringify!(RT_QUEUE))
    );
    assert_eq!(
        ::std::mem::align_of::<RT_QUEUE>(),
        8usize,
        concat!("Alignment of ", stringify!(RT_QUEUE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE),
            "::",
            stringify!(handle)
        )
    );
}
#[doc = " @brief Queue status descriptor"]
#[doc = " @anchor RT_QUEUE_INFO"]
#[doc = ""]
#[doc = " This structure reports various static and runtime information about"]
#[doc = " a real-time queue, returned by a call to rt_queue_inquire()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RT_QUEUE_INFO {
    #[doc = " Number of tasks currently waiting on the queue for"]
    #[doc = " messages."]
    pub nwaiters: ::std::os::raw::c_int,
    #[doc = " Number of messages pending in queue."]
    pub nmessages: ::std::os::raw::c_int,
    #[doc = " Queue mode bits, as given to rt_queue_create()."]
    pub mode: ::std::os::raw::c_int,
    #[doc = " Maximum number of messages in queue, zero if unlimited."]
    pub qlimit: size_t,
    #[doc = " Size of memory pool for holding message buffers (in bytes)."]
    pub poolsize: size_t,
    #[doc = " Amount of memory consumed from the buffer pool."]
    pub usedmem: size_t,
    #[doc = " Name of message queue."]
    pub name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_RT_QUEUE_INFO() {
    assert_eq!(
        ::std::mem::size_of::<RT_QUEUE_INFO>(),
        72usize,
        concat!("Size of: ", stringify!(RT_QUEUE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<RT_QUEUE_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(RT_QUEUE_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).nwaiters as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(nwaiters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).nmessages as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(nmessages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).qlimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(qlimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).poolsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(poolsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).usedmem as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(usedmem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RT_QUEUE_INFO>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RT_QUEUE_INFO),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    pub fn rt_queue_create(
        queue: *mut RT_QUEUE,
        name: *const ::std::os::raw::c_char,
        poolsize: size_t,
        qlimit: size_t,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_delete(queue: *mut RT_QUEUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_alloc(queue: *mut RT_QUEUE, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rt_queue_free(
        queue: *mut RT_QUEUE,
        buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_send(
        queue: *mut RT_QUEUE,
        buf: *const ::std::os::raw::c_void,
        size: size_t,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_write(
        queue: *mut RT_QUEUE,
        buf: *const ::std::os::raw::c_void,
        size: size_t,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_receive_timed(
        queue: *mut RT_QUEUE,
        bufp: *mut *mut ::std::os::raw::c_void,
        abs_timeout: *const timespec,
    ) -> ssize_t;
}
extern "C" {
    pub fn rt_queue_read_timed(
        queue: *mut RT_QUEUE,
        buf: *mut ::std::os::raw::c_void,
        size: size_t,
        abs_timeout: *const timespec,
    ) -> ssize_t;
}
extern "C" {
    pub fn rt_queue_flush(queue: *mut RT_QUEUE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_inquire(
        queue: *mut RT_QUEUE,
        info: *mut RT_QUEUE_INFO,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_bind(
        queue: *mut RT_QUEUE,
        name: *const ::std::os::raw::c_char,
        timeout: RTIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_queue_unbind(queue: *mut RT_QUEUE) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alchemy_queue {
    pub magic: ::std::os::raw::c_uint,
    pub name: [::std::os::raw::c_char; 32usize],
    pub mode: ::std::os::raw::c_int,
    pub limit: size_t,
    pub hobj: heapobj,
    pub sobj: syncobj,
    pub cobj: clusterobj,
    pub mq: listobj,
    pub mcount: ::std::os::raw::c_uint,
    pub fsobj: fsobj,
}
#[test]
fn bindgen_test_layout_alchemy_queue() {
    assert_eq!(
        ::std::mem::size_of::<alchemy_queue>(),
        512usize,
        concat!("Size of: ", stringify!(alchemy_queue))
    );
    assert_eq!(
        ::std::mem::align_of::<alchemy_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(alchemy_queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).mode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).limit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).hobj as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(hobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).sobj as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(sobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).cobj as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(cobj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).mq as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(mq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).mcount as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(mcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue>())).fsobj as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue),
            "::",
            stringify!(fsobj)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alchemy_queue_msg {
    pub size: size_t,
    pub refcount: ::std::os::raw::c_uint,
    pub next: holder,
}
#[test]
fn bindgen_test_layout_alchemy_queue_msg() {
    assert_eq!(
        ::std::mem::size_of::<alchemy_queue_msg>(),
        32usize,
        concat!("Size of: ", stringify!(alchemy_queue_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<alchemy_queue_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(alchemy_queue_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue_msg>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue_msg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue_msg>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue_msg),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue_msg>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue_msg),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alchemy_queue_wait {
    pub msg: memoff_t,
    pub local_buf: *mut ::std::os::raw::c_void,
    pub local_bufsz: size_t,
}
#[test]
fn bindgen_test_layout_alchemy_queue_wait() {
    assert_eq!(
        ::std::mem::size_of::<alchemy_queue_wait>(),
        24usize,
        concat!("Size of: ", stringify!(alchemy_queue_wait))
    );
    assert_eq!(
        ::std::mem::align_of::<alchemy_queue_wait>(),
        8usize,
        concat!("Alignment of ", stringify!(alchemy_queue_wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue_wait>())).msg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue_wait),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue_wait>())).local_buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue_wait),
            "::",
            stringify!(local_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alchemy_queue_wait>())).local_bufsz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(alchemy_queue_wait),
            "::",
            stringify!(local_bufsz)
        )
    );
}
extern "C" {
    pub static mut alchemy_queue_table: syncluster;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
